/* THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY LLnextgen. DO NOT EDIT */
#define LL_NTERMINALS 41
#define LL_NSETS 20
#define LL_SSETS 8
#define LLinset(LLx) (LLsets[LLx*LL_SSETS + (LLcsymb/8)] & (1<<(LLcsymb & 7)))
#define LL_SCANDONE(LLx) if (LLsymb != LLx) LLerror(LLx);
static int LLscnt[LL_NSETS+1], LLtcnt[LL_NTERMINALS];
static int LLcsymb;
#include <string.h>
static const char LLsets[] = {
	'\x00', 	'\x1E', 	'\x01', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\xC8', 	'\x00', 	'\xF8', 	'\x2F', 	'\xCE', 	'\x01', 	'\x00', 	'\x00', 
	'\x80', 	'\x00', 	'\xF8', 	'\x2F', 	'\xCE', 	'\x01', 	'\x00', 	'\x00', 
	'\x00', 	'\x18', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x80', 	'\xE8', 	'\x00', 	'\x00', 	'\x02', 	'\x00', 	'\x00', 	'\x00', 
	'\x80', 	'\x10', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x3C', 	'\x00', 	'\x00', 	'\x00', 
	'\x00', 	'\x00', 	'\x80', 	'\x2D', 	'\xCE', 	'\x01', 	'\x00', 	'\x00', 
	'\x80', 	'\x00', 	'\x18', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x80', 	'\x00', 	'\x08', 	'\x00', 	'\x02', 	'\x00', 	'\x00', 	'\x00', 
	'\x80', 	'\x00', 	'\x10', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x00', 	'\x00', 	'\x60', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x80', 	'\x00', 	'\x20', 	'\x00', 	'\x02', 	'\x00', 	'\x00', 	'\x00', 
	'\x80', 	'\x00', 	'\x40', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x00', 	'\x00', 	'\x00', 	'\x2C', 	'\xCE', 	'\x01', 	'\x00', 	'\x00', 
	'\x00', 	'\x00', 	'\x00', 	'\x0C', 	'\xCE', 	'\x01', 	'\x00', 	'\x00', 
	'\x80', 	'\x00', 	'\x00', 	'\x6C', 	'\xCE', 	'\x01', 	'\x00', 	'\x00', 
	'\x00', 	'\x00', 	'\x00', 	'\x0C', 	'\x4E', 	'\x01', 	'\x00', 	'\x00', 
	'\x00', 	'\x00', 	'\x00', 	'\x0C', 	'\x4E', 	'\x00', 	'\x00', 	'\x00', 
	'\x00', 	'\x00', 	'\x00', 	'\x04', 	'\x4E', 	'\x00', 	'\x00', 	'\x00', 
	0
};
static const int LLindex[] = { 0,
	   0,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	   0,    1,    2,    3,    4,    5,    6,    7,
	   8,    9,   10,   11,   12,   13,   14,   15,
	  16,   17,   18,   19,   20,   21,   22,   23,
	  24,   25,   26,   27,   28,   29,   30,   31,
	  32,   33,   34,   35,   36,   37,   38,   39,
	  40};
int LLsymb;
static int LLreissue;
int yylex(void);
static int LLlexerWrapper(void) {
	if (LLreissue == -2 /* LL_NEW_TOKEN */) {
		return yylex();
	} else {
		int LLretval = LLreissue;
		LLreissue = -2 /* LL_NEW_TOKEN */;
		return LLretval;
	}
}
void LLmessage(int);
static void LLread(void) { LLcsymb = LLindex[(LLsymb = LLlexerWrapper()) + 1]; }
static int LLskip(void) {
	int LL_i;
	if (LLcsymb >= 0) {
		if (LLtcnt[LLcsymb] != 0) return 0;
		for (LL_i = 0; LL_i < LL_NSETS; LL_i++)
			if (LLscnt[LL_i] != 0 && LLinset(LL_i))
				return 0;
	}

	for (;;) {
		LLmessage(0 /* LL_DELETE */);
		while ((LLcsymb = LLindex[(LLsymb = LLlexerWrapper()) + 1]) < 0) LLmessage(0 /* LL_DELETE */);
		if (LLtcnt[LLcsymb] != 0)
			return 1;
		for (LL_i = 0; LL_i < LL_NSETS; LL_i++)
			if (LLscnt[LL_i] != 0 && LLinset(LL_i))
				return 1;
	}
}
static void LLerror(int LLtoken) {
	if (LLtoken == 256 /* EOFILE */) {
		LLmessage(-1 /* LL_MISSINGEOF */);
		while (LLindex[(LLsymb = LLlexerWrapper()) + 1] != 0) /*NOTHING*/ ;
		return;
	}
	LLtcnt[LLindex[LLtoken + 1]]++;
	LLskip();
	LLtcnt[LLindex[LLtoken + 1]]--;
	if (LLsymb != LLtoken) { LLreissue = LLsymb; LLmessage(LLtoken); }
}
#include "parser.h"
#line 1 "parser.g"

/**********************************************/
#include <stdio.h>
#include <stdlib.h>
#include "scanner_specification.h"
#include "code_generator.h"

extern char *yytext;
extern int line;
/**********************************************/

#line 130 "parser.c"
static void LL0_Input(void);
static void LL1_SpecificationFile(void);
static void LL2_OptionsSection(void);
static void LL3_DefinesSection(void);
static void LL4_RegExpsSection(void);
static void LL5_RegularExpressionSet(void);
static void LL6_RegularExpression
#line 76 "parser.g"
(RegexTree *node)
#line 140 "parser.c"
;
static void LL7_Term
#line 82 "parser.g"
(RegexTree *node)
#line 145 "parser.c"
;
static void LL8_Factor
#line 87 "parser.g"
(RegexTree *node)
#line 150 "parser.c"
;
static void LL0_Input(void){
LL1_SpecificationFile();
}
static void LL1_SpecificationFile(void){
LLtcnt[1]++;
LLtcnt[2]++;
LLscnt[1]++;
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
LLtcnt[1]--;
break;
case 2:/* BEGIN_SECTION_DEFINES */
case 3:/* BEGIN_SECTION_REGEXPS */
LLtcnt[1]--;
break;
case 1:/* BEGIN_SECTION_OPTIONS */
LLtcnt[1]--;
LLscnt[0]++;
LLtcnt[4]++;
LLtcnt[7]++;
LL_SCANDONE(257);/* BEGIN_SECTION_OPTIONS */
LLread();
LLscnt[0]--;
LL2_OptionsSection();
LLtcnt[4]--;
LL_SCANDONE(260);/* END_SECTION_OPTIONS */
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
}
LL_1:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_1;
LLtcnt[2]--;
break;
case 3:/* BEGIN_SECTION_REGEXPS */
LLtcnt[2]--;
break;
case 2:/* BEGIN_SECTION_DEFINES */
LLtcnt[2]--;
LLtcnt[17]++;
LLtcnt[5]++;
LLtcnt[7]++;
LL_SCANDONE(258);/* BEGIN_SECTION_DEFINES */
#line 31 "parser.g"
{initializeDefinitionsSection();}
#line 202 "parser.c"
LLread();
LLtcnt[17]--;
LL3_DefinesSection();
LLtcnt[5]--;
LL_SCANDONE(261);/* END_SECTION_DEFINES */
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
}
LLscnt[1]--;
LLscnt[2]++;
LLtcnt[6]++;
LLtcnt[7]++;
LL_SCANDONE(259);/* BEGIN_SECTION_REGEXPS */
#line 32 "parser.g"
{initializeRegexTrees();}
#line 220 "parser.c"
LLread();
LLscnt[2]--;
LL4_RegExpsSection();
LLtcnt[6]--;
LL_SCANDONE(262);/* END_SECTION_REGEXPS */
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
#line 32 "parser.g"
{printOptions(); printDefinitions(); printTokensAndActions(); convertAndSaveDFAs(); createOutputCode("scanner.c"); exit(EXIT_SUCCESS);}
#line 231 "parser.c"
}
static void LL2_OptionsSection(void){
LLtcnt[9]++;
LLtcnt[10]++;
LLscnt[3]++;
LLtcnt[16]++;
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
LLtcnt[9]--;
break;
case 4:/* END_SECTION_OPTIONS */
case 10:/* LEXEME_OPTION */
case 11:/* POSITIONING_OPTION_ON */
case 12:/* POSITIONING_OPTION_OFF */
case 16:/* DEFAULT_ACTION_OPTION */
LLtcnt[9]--;
break;
case 9:/* LEXER_OPTION */
LLtcnt[9]--;
LLtcnt[33]++;
LLtcnt[7]++;
LL_SCANDONE(265);/* LEXER_OPTION */
LLread();
LLtcnt[33]--;
LL_SCANDONE(289);/* IDENTIFIER */
#line 36 "parser.g"
{setLexerRoutine(yytext);}
#line 261 "parser.c"
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
}
LL_1:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_1;
LLtcnt[10]--;
break;
case 4:/* END_SECTION_OPTIONS */
case 11:/* POSITIONING_OPTION_ON */
case 12:/* POSITIONING_OPTION_OFF */
case 16:/* DEFAULT_ACTION_OPTION */
LLtcnt[10]--;
break;
case 10:/* LEXEME_OPTION */
LLtcnt[10]--;
LLtcnt[33]++;
LLtcnt[7]++;
LL_SCANDONE(266);/* LEXEME_OPTION */
LLread();
LLtcnt[33]--;
LL_SCANDONE(289);/* IDENTIFIER */
#line 37 "parser.g"
{setLexemeName(yytext);}
#line 289 "parser.c"
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
}
LL_2:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_2;
LLscnt[3]--;
break;
case 4:/* END_SECTION_OPTIONS */
case 16:/* DEFAULT_ACTION_OPTION */
LLscnt[3]--;
break;
case 11:/* POSITIONING_OPTION_ON */
case 12:/* POSITIONING_OPTION_OFF */
LLscnt[3]--;
switch (LLcsymb) {
case 11:/* POSITIONING_OPTION_ON */
LLscnt[4]++;
LLscnt[4]--;
LLtcnt[7]++;
LLtcnt[13]++;
LLtcnt[14]++;
LLtcnt[33]++;
LLtcnt[7]++;
LLtcnt[15]++;
LLtcnt[33]++;
LLtcnt[7]++;
LL_SCANDONE(267);/* POSITIONING_OPTION_ON */
#line 38 "parser.g"
{setPositioningOption(TRUE);}
#line 323 "parser.c"
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
LLtcnt[13]--;
LL_SCANDONE(269);/* WHERE_CLAUSE */
LLread();
LLtcnt[14]--;
LL_SCANDONE(270);/* POSITIONING_LINE */
LLread();
LLtcnt[33]--;
LL_SCANDONE(289);/* IDENTIFIER */
#line 39 "parser.g"
{setPositioningLineName(yytext);}
#line 338 "parser.c"
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
LLtcnt[15]--;
LL_SCANDONE(271);/* POSITIONING_COLUMN */
LLread();
LLtcnt[33]--;
LL_SCANDONE(289);/* IDENTIFIER */
#line 40 "parser.g"
{setPositioningColumneName(yytext);}
#line 350 "parser.c"
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
break;
default:
LLscnt[5]++;
LLscnt[5]--;
LLtcnt[7]++;
LL_SCANDONE(268);/* POSITIONING_OPTION_OFF */
#line 41 "parser.g"
{setPositioningOption(FALSE);}
#line 363 "parser.c"
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
break;
}
}
LL_3:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_3;
LLtcnt[16]--;
break;
case 4:/* END_SECTION_OPTIONS */
LLtcnt[16]--;
break;
case 16:/* DEFAULT_ACTION_OPTION */
LLtcnt[16]--;
LLtcnt[33]++;
LLtcnt[7]++;
LL_SCANDONE(272);/* DEFAULT_ACTION_OPTION */
LLread();
LLtcnt[33]--;
LL_SCANDONE(289);/* IDENTIFIER */
#line 42 "parser.g"
{setDefaultActionRoutineName(yytext);}
#line 390 "parser.c"
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
}
}
static void LL3_DefinesSection(void){
#line 46 "parser.g"
 char *identifier; 
#line 400 "parser.c"
LLtcnt[17]++;
for (;;) {
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
break;
case 5:/* END_SECTION_DEFINES */
break;
case 17:/* DEFINE */
LLtcnt[33]++;
LLtcnt[18]++;
LLtcnt[31]++;
LLscnt[6]++;
LLtcnt[8]++;
LLtcnt[32]++;
LLtcnt[7]++;
LL_SCANDONE(273);/* DEFINE */
LLread();
LLtcnt[33]--;
LL_SCANDONE(289);/* IDENTIFIER */
#line 47 "parser.g"
{ identifier = malloc(sizeof(char) * strlen(yytext)+1); strcpy(identifier, yytext); }
#line 424 "parser.c"
LLread();
LLtcnt[18]--;
LL_SCANDONE(274);/* EQUALS */
LLread();
LLtcnt[31]--;
LL_SCANDONE(287);/* OPEN_BRACES */
LLread();
LL_1:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_1;
/*FALLTHROUGH*/
case 34:/* LITERAL_INT */
LLscnt[6]--;
LL_SCANDONE(290);/* LITERAL_INT */
#line 48 "parser.g"
{addLiteralToDefinition(identifier, yytext);}
#line 443 "parser.c"
break;
case 35:/* LITERAL_CHAR */
LLscnt[6]--;
LL_SCANDONE(291);/* LITERAL_CHAR */
#line 49 "parser.g"
{addLiteralToDefinition(identifier, yytext);}
#line 450 "parser.c"
break;
case 36:/* RANGE_INT */
LLscnt[6]--;
LL_SCANDONE(292);/* RANGE_INT */
#line 50 "parser.g"
{addRangeToDefinition(identifier, yytext);}
#line 457 "parser.c"
break;
case 37:/* RANGE_CHAR */
LLscnt[6]--;
LL_SCANDONE(293);/* RANGE_CHAR */
#line 51 "parser.g"
{addRangeToDefinition(identifier, yytext);}
#line 464 "parser.c"
break;
}
LLread();
for (;;) {
LL_2:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_2;
break;
case 32:/* CLOSE_BRACES */
break;
case 8:/* COMMA */
LLscnt[6]++;
LL_SCANDONE(264);/* COMMA */
LLread();
LL_3:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_3;
/*FALLTHROUGH*/
case 34:/* LITERAL_INT */
LLscnt[6]--;
LL_SCANDONE(290);/* LITERAL_INT */
#line 52 "parser.g"
{addLiteralToDefinition(identifier, yytext);}
#line 491 "parser.c"
break;
case 35:/* LITERAL_CHAR */
LLscnt[6]--;
LL_SCANDONE(291);/* LITERAL_CHAR */
#line 53 "parser.g"
{addLiteralToDefinition(identifier, yytext);}
#line 498 "parser.c"
break;
case 36:/* RANGE_INT */
LLscnt[6]--;
LL_SCANDONE(292);/* RANGE_INT */
#line 54 "parser.g"
{addRangeToDefinition(identifier, yytext);}
#line 505 "parser.c"
break;
case 37:/* RANGE_CHAR */
LLscnt[6]--;
LL_SCANDONE(293);/* RANGE_CHAR */
#line 55 "parser.g"
{addRangeToDefinition(identifier, yytext);}
#line 512 "parser.c"
break;
}
LLread();
continue;
}
LLtcnt[8]--;
break;
}
LLtcnt[32]--;
LL_SCANDONE(288);/* CLOSE_BRACES */
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
continue;
}
LLtcnt[17]--;
break;
}
#line 56 "parser.g"
{free(identifier);}
#line 534 "parser.c"
}
static void LL4_RegExpsSection(void){
#line 60 "parser.g"
   RegexTree *r; 
#line 539 "parser.c"
LLscnt[2]++;
switch (LLcsymb) {
case 25:/* REGEXP_DEF */
break;
default: LLskip(); break;
}
LLscnt[2]--;
LLtcnt[25]++;
goto LL_0;
for (;;) {
LL_1:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_1;
break;
case 6:/* END_SECTION_REGEXPS */
break;
case 25:/* REGEXP_DEF */
LL_0:
LLscnt[7]++;
LLtcnt[7]++;
LLscnt[8]++;
LLscnt[11]++;
LL_SCANDONE(281);/* REGEXP_DEF */
LLread();
LL_2:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_2;
/*FALLTHROUGH*/
case 26:/* TOKEN_EPSILON */
case 27:/* OPEN_PARENTHESIS */
case 29:/* OPEN_CURLYBRACES */
case 33:/* IDENTIFIER */
case 34:/* LITERAL_INT */
case 35:/* LITERAL_CHAR */
case 38:/* OPERAND */
LLscnt[7]--;
LLscnt[14]++;
LL5_RegularExpressionSet();
break;
case 23:/* REGEXP_EOF */
LLscnt[7]--;
#line 61 "parser.g"
{ r = regexTreeCreateEOFTree(); evaluateRegexTree(r); addTreeToArray(r); }
#line 586 "parser.c"
LL_SCANDONE(279);/* REGEXP_EOF */
LLread();
break;
case 24:/* REGEXP_ANYCHAR */
LLscnt[7]--;
#line 61 "parser.g"
{ r = regexTreeCreateAnycharTree(); evaluateRegexTree(r); addTreeToArray(r); }
#line 594 "parser.c"
LL_SCANDONE(280);/* REGEXP_ANYCHAR */
LLread();
break;
}
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
LL_3:
switch (LLcsymb) {
case 19:/* TOKEN_DEF */
LLscnt[8]--;
LLscnt[9]++;
LLscnt[9]--;
LLtcnt[33]++;
LLtcnt[7]++;
LL_SCANDONE(275);/* TOKEN_DEF */
LLread();
LLtcnt[33]--;
LL_SCANDONE(289);/* IDENTIFIER */
#line 62 "parser.g"
{ addToken(yytext); }
#line 616 "parser.c"
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
break;
default:
if (LLskip())
goto LL_3;
/*FALLTHROUGH*/
case 20:/* NO_TOKEN_DEF */
LLscnt[8]--;
LLscnt[10]++;
LLscnt[10]--;
LLtcnt[7]++;
LL_SCANDONE(276);/* NO_TOKEN_DEF */
#line 62 "parser.g"
{ addNoToken(); }
#line 633 "parser.c"
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
break;
}
#line 63 "parser.g"
{ addDefaultAction(); }
#line 641 "parser.c"
LLread();
LL_4:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_4;
LLscnt[11]--;
break;
case 6:/* END_SECTION_REGEXPS */
case 25:/* REGEXP_DEF */
LLscnt[11]--;
break;
case 21:/* ACTION_DEF */
case 22:/* NO_ACTION_DEF */
LLscnt[11]--;
switch (LLcsymb) {
case 21:/* ACTION_DEF */
LLscnt[12]++;
LLscnt[12]--;
LLtcnt[33]++;
LLtcnt[7]++;
LL_SCANDONE(277);/* ACTION_DEF */
LLread();
LLtcnt[33]--;
LL_SCANDONE(289);/* IDENTIFIER */
#line 63 "parser.g"
{ addAction(yytext); }
#line 668 "parser.c"
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
break;
default:
LLscnt[13]++;
LLscnt[13]--;
LLtcnt[7]++;
LL_SCANDONE(278);/* NO_ACTION_DEF */
#line 63 "parser.g"
{ addNoAction(); }
#line 681 "parser.c"
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
break;
}
}
continue;
}
LLtcnt[25]--;
break;
}
}
static void LL5_RegularExpressionSet(void){
#line 67 "parser.g"
   RegexTree *rSet;
    RegexTree *new_regex_ptr;
    RegexTree *r;
    RegexTree *tree_ptr; 
#line 701 "parser.c"
LL_0:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 26:/* TOKEN_EPSILON */
case 27:/* OPEN_PARENTHESIS */
case 33:/* IDENTIFIER */
case 34:/* LITERAL_INT */
case 35:/* LITERAL_CHAR */
case 38:/* OPERAND */
LLscnt[14]--;
LLscnt[15]++;
#line 71 "parser.g"
{ r = makeNewRegexTree(); tree_ptr = r; }
#line 718 "parser.c"
LLscnt[15]--;
LL6_RegularExpression
#line 71 "parser.g"
(tree_ptr)
#line 723 "parser.c"
;
#line 71 "parser.g"
{ evaluateRegexTree(r); addTreeToArray(r); }
#line 727 "parser.c"
break;
case 29:/* OPEN_CURLYBRACES */
LLscnt[14]--;
LLscnt[16]++;
LLscnt[16]--;
LLscnt[15]++;
LLtcnt[7]++;
LLtcnt[30]++;
LL_SCANDONE(285);/* OPEN_CURLYBRACES */
#line 72 "parser.g"
{ rSet = makeNewRegexSetTree(); new_regex_ptr = addRegexToRegexSetTree(rSet); }
#line 739 "parser.c"
LLread();
LLscnt[15]--;
LL6_RegularExpression
#line 72 "parser.g"
(new_regex_ptr)
#line 745 "parser.c"
;
for (;;) {
LL_1:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_1;
break;
case 30:/* CLOSE_CURLYBRACES */
break;
case 7:/* SEMICOLON */
LLscnt[15]++;
LL_SCANDONE(263);/* SEMICOLON */
#line 73 "parser.g"
{ new_regex_ptr = addRegexToRegexSetTree(rSet); }
#line 760 "parser.c"
LLread();
LLscnt[15]--;
LL6_RegularExpression
#line 73 "parser.g"
(new_regex_ptr)
#line 766 "parser.c"
;
continue;
}
LLtcnt[7]--;
break;
}
LLtcnt[30]--;
LL_SCANDONE(286);/* CLOSE_CURLYBRACES */
#line 73 "parser.g"
{ evaluateRegexTree(rSet); addTreeToArray(rSet); }
#line 777 "parser.c"
LLread();
break;
}
}
static void LL6_RegularExpression
#line 76 "parser.g"
(RegexTree *node)
#line 785 "parser.c"
{
#line 77 "parser.g"
 RegexTree *child; int operation_type; 
#line 789 "parser.c"
LLtcnt[39]++;
#line 78 "parser.g"
{ child = regexTreeAddTerm(node); }
#line 793 "parser.c"
LL7_Term
#line 78 "parser.g"
(child)
#line 797 "parser.c"
;
for (;;) {
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
break;
case 7:/* SEMICOLON */
case 28:/* CLOSE_PARENTHESIS */
case 30:/* CLOSE_CURLYBRACES */
break;
case 39:/* BINARYOP */
LLscnt[17]++;
LL_SCANDONE(295);/* BINARYOP */
#line 79 "parser.g"
{ operation_type = parseOperationsToType(yytext); regexTreeAddBinary(node, operation_type); }
#line 814 "parser.c"
#line 79 "parser.g"
{ child = regexTreeAddTerm(node); }
#line 817 "parser.c"
LLread();
LLscnt[17]--;
LL7_Term
#line 79 "parser.g"
(child)
#line 823 "parser.c"
;
continue;
}
LLtcnt[39]--;
break;
}
}
static void LL7_Term
#line 82 "parser.g"
(RegexTree *node)
#line 834 "parser.c"
{
#line 83 "parser.g"
 RegexTree *child; int operation_type; 
#line 838 "parser.c"
LLscnt[18]++;
LLtcnt[40]++;
#line 84 "parser.g"
{ child = regexTreeAddFactor(node); }
#line 843 "parser.c"
LL8_Factor
#line 84 "parser.g"
(child)
#line 847 "parser.c"
;
LLread();
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
LLtcnt[40]--;
break;
case 7:/* SEMICOLON */
case 28:/* CLOSE_PARENTHESIS */
case 30:/* CLOSE_CURLYBRACES */
case 39:/* BINARYOP */
LLtcnt[40]--;
break;
case 40:/* UNARYOP */
LLtcnt[40]--;
LL_SCANDONE(296);/* UNARYOP */
#line 84 "parser.g"
{ operation_type = parseOperationsToType(yytext); regexTreeAddUnary(node, operation_type); }
#line 867 "parser.c"
LLread();
}
}
static void LL8_Factor
#line 87 "parser.g"
(RegexTree *node)
#line 874 "parser.c"
{
#line 88 "parser.g"
 RegexTree *child; 
#line 878 "parser.c"
LL_0:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 26:/* TOKEN_EPSILON */
case 33:/* IDENTIFIER */
case 34:/* LITERAL_INT */
case 35:/* LITERAL_CHAR */
case 38:/* OPERAND */
LLscnt[18]--;
LLscnt[19]++;
LL_1:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_1;
/*FALLTHROUGH*/
case 38:/* OPERAND */
LLscnt[19]--;
LL_SCANDONE(294);/* OPERAND */
break;
case 35:/* LITERAL_CHAR */
LLscnt[19]--;
LL_SCANDONE(291);/* LITERAL_CHAR */
break;
case 34:/* LITERAL_INT */
LLscnt[19]--;
LL_SCANDONE(290);/* LITERAL_INT */
break;
case 33:/* IDENTIFIER */
LLscnt[19]--;
LL_SCANDONE(289);/* IDENTIFIER */
break;
case 26:/* TOKEN_EPSILON */
LLscnt[19]--;
LL_SCANDONE(282);/* TOKEN_EPSILON */
break;
}
#line 89 "parser.g"
{ regexTreeAddValue(node, yytext); }
#line 921 "parser.c"
break;
case 27:/* OPEN_PARENTHESIS */
LLscnt[18]--;
LLscnt[15]++;
LLtcnt[28]++;
LL_SCANDONE(283);/* OPEN_PARENTHESIS */
#line 90 "parser.g"
{ child = regexTreeAddRegex(node);}
#line 930 "parser.c"
LLread();
LLscnt[15]--;
LL6_RegularExpression
#line 90 "parser.g"
(child)
#line 936 "parser.c"
;
LLtcnt[28]--;
LL_SCANDONE(284);/* CLOSE_PARENTHESIS */
break;
}
}
#line 94 "parser.g"

/*****************************************************************/
/* the following code is copied verbatim in the generated C file */

void LLmessage(int token) {
    printf("\nSyntax error around \"%s\" on line %d. Aborting...\n", yytext, line);
    exit(-1);
}

int main() {
    LLparser();
    return 0;
}

/*****************************************************************/

#line 960 "parser.c"
void LLparser(void) {
	memset(LLscnt, 0, LL_NSETS * sizeof(int));
	memset(LLtcnt, 0, LL_NTERMINALS * sizeof(int));
	LLtcnt[0]++;
	LLsymb = 0;
	LLreissue = -2 /* LL_NEW_TOKEN */;
	LLread();
	LL0_Input();
	LLread();
	if (LLcsymb != 0) LLerror(256 /* EOFILE*/);
}

