/* THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY LLnextgen. DO NOT EDIT */
#define LL_NTERMINALS 41
#define LL_NSETS 20
#define LL_SSETS 8
#define LLinset(LLx) (LLsets[LLx*LL_SSETS + (LLcsymb/8)] & (1<<(LLcsymb & 7)))
#define LL_SCANDONE(LLx) if (LLsymb != LLx) LLerror(LLx);
static int LLscnt[LL_NSETS+1], LLtcnt[LL_NTERMINALS];
static int LLcsymb;
#include <string.h>
static const char LLsets[] = {
	'\x00', 	'\x1E', 	'\x01', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\xC8', 	'\x00', 	'\xF8', 	'\x2F', 	'\xCE', 	'\x01', 	'\x00', 	'\x00', 
	'\x80', 	'\x00', 	'\xF8', 	'\x2F', 	'\xCE', 	'\x01', 	'\x00', 	'\x00', 
	'\x00', 	'\x18', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x80', 	'\xE8', 	'\x00', 	'\x00', 	'\x02', 	'\x00', 	'\x00', 	'\x00', 
	'\x80', 	'\x10', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x3C', 	'\x00', 	'\x00', 	'\x00', 
	'\x00', 	'\x00', 	'\x80', 	'\x2D', 	'\xCE', 	'\x01', 	'\x00', 	'\x00', 
	'\x80', 	'\x00', 	'\x18', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x80', 	'\x00', 	'\x08', 	'\x00', 	'\x02', 	'\x00', 	'\x00', 	'\x00', 
	'\x80', 	'\x00', 	'\x10', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x00', 	'\x00', 	'\x60', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x80', 	'\x00', 	'\x20', 	'\x00', 	'\x02', 	'\x00', 	'\x00', 	'\x00', 
	'\x80', 	'\x00', 	'\x40', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x00', 	'\x00', 	'\x00', 	'\x2C', 	'\xCE', 	'\x01', 	'\x00', 	'\x00', 
	'\x00', 	'\x00', 	'\x00', 	'\x0C', 	'\xCE', 	'\x01', 	'\x00', 	'\x00', 
	'\x80', 	'\x00', 	'\x00', 	'\x6C', 	'\xCE', 	'\x01', 	'\x00', 	'\x00', 
	'\x00', 	'\x00', 	'\x00', 	'\x0C', 	'\x4E', 	'\x01', 	'\x00', 	'\x00', 
	'\x00', 	'\x00', 	'\x00', 	'\x0C', 	'\x4E', 	'\x00', 	'\x00', 	'\x00', 
	'\x00', 	'\x00', 	'\x00', 	'\x04', 	'\x4E', 	'\x00', 	'\x00', 	'\x00', 
	0
};
static const int LLindex[] = { 0,
	   0,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	   0,    1,    2,    3,    4,    5,    6,    7,
	   8,    9,   10,   11,   12,   13,   14,   15,
	  16,   17,   18,   19,   20,   21,   22,   23,
	  24,   25,   26,   27,   28,   29,   30,   31,
	  32,   33,   34,   35,   36,   37,   38,   39,
	  40};
int LLsymb;
static int LLreissue;
int yylex(void);
static int LLlexerWrapper(void) {
	if (LLreissue == -2 /* LL_NEW_TOKEN */) {
		return yylex();
	} else {
		int LLretval = LLreissue;
		LLreissue = -2 /* LL_NEW_TOKEN */;
		return LLretval;
	}
}
void LLmessage(int);
static void LLread(void) { LLcsymb = LLindex[(LLsymb = LLlexerWrapper()) + 1]; }
static int LLskip(void) {
	int LL_i;
	if (LLcsymb >= 0) {
		if (LLtcnt[LLcsymb] != 0) return 0;
		for (LL_i = 0; LL_i < LL_NSETS; LL_i++)
			if (LLscnt[LL_i] != 0 && LLinset(LL_i))
				return 0;
	}

	for (;;) {
		LLmessage(0 /* LL_DELETE */);
		while ((LLcsymb = LLindex[(LLsymb = LLlexerWrapper()) + 1]) < 0) LLmessage(0 /* LL_DELETE */);
		if (LLtcnt[LLcsymb] != 0)
			return 1;
		for (LL_i = 0; LL_i < LL_NSETS; LL_i++)
			if (LLscnt[LL_i] != 0 && LLinset(LL_i))
				return 1;
	}
}
static void LLerror(int LLtoken) {
	if (LLtoken == 256 /* EOFILE */) {
		LLmessage(-1 /* LL_MISSINGEOF */);
		while (LLindex[(LLsymb = LLlexerWrapper()) + 1] != 0) /*NOTHING*/ ;
		return;
	}
	LLtcnt[LLindex[LLtoken + 1]]++;
	LLskip();
	LLtcnt[LLindex[LLtoken + 1]]--;
	if (LLsymb != LLtoken) { LLreissue = LLsymb; LLmessage(LLtoken); }
}
#include "parser.h"
#line 1 "parser.g"

/**********************************************/
#include <stdio.h>
#include <stdlib.h>
#include "scanner_specification.h"

extern char *yytext;
extern int line;
/**********************************************/

#line 129 "parser.c"
static void LL0_Input(void);
static void LL1_SpecificationFile(void);
static void LL2_OptionsSection(void);
static void LL3_DefinesSection(void);
static void LL4_RegExpsSection(void);
static void LL5_RegularExpressionSet(void);
static void LL6_RegularExpression
#line 74 "parser.g"
(RegexTree *node)
#line 139 "parser.c"
;
static void LL7_Term
#line 80 "parser.g"
(RegexTree *node)
#line 144 "parser.c"
;
static void LL8_Factor
#line 85 "parser.g"
(RegexTree *node)
#line 149 "parser.c"
;
static void LL0_Input(void){
LL1_SpecificationFile();
}
static void LL1_SpecificationFile(void){
LLtcnt[1]++;
LLtcnt[2]++;
LLscnt[1]++;
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
LLtcnt[1]--;
break;
case 2:/* BEGIN_SECTION_DEFINES */
case 3:/* BEGIN_SECTION_REGEXPS */
LLtcnt[1]--;
break;
case 1:/* BEGIN_SECTION_OPTIONS */
LLtcnt[1]--;
LLscnt[0]++;
LLtcnt[4]++;
LLtcnt[7]++;
LL_SCANDONE(257);/* BEGIN_SECTION_OPTIONS */
LLread();
LLscnt[0]--;
LL2_OptionsSection();
LLtcnt[4]--;
LL_SCANDONE(260);/* END_SECTION_OPTIONS */
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
}
LL_1:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_1;
LLtcnt[2]--;
break;
case 3:/* BEGIN_SECTION_REGEXPS */
LLtcnt[2]--;
break;
case 2:/* BEGIN_SECTION_DEFINES */
LLtcnt[2]--;
LLtcnt[17]++;
LLtcnt[5]++;
LLtcnt[7]++;
LL_SCANDONE(258);/* BEGIN_SECTION_DEFINES */
#line 30 "parser.g"
{initializeDefinitionsSection();}
#line 201 "parser.c"
LLread();
LLtcnt[17]--;
LL3_DefinesSection();
LLtcnt[5]--;
LL_SCANDONE(261);/* END_SECTION_DEFINES */
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
}
LLscnt[1]--;
LLscnt[2]++;
LLtcnt[6]++;
LLtcnt[7]++;
LL_SCANDONE(259);/* BEGIN_SECTION_REGEXPS */
#line 31 "parser.g"
{initializeRegexTrees();}
#line 219 "parser.c"
LLread();
LLscnt[2]--;
LL4_RegExpsSection();
LLtcnt[6]--;
LL_SCANDONE(262);/* END_SECTION_REGEXPS */
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
#line 31 "parser.g"
{printOptions(); printDefinitions(); printTokensAndActions(); exit(EXIT_SUCCESS);}
#line 230 "parser.c"
}
static void LL2_OptionsSection(void){
LLtcnt[9]++;
LLtcnt[10]++;
LLscnt[3]++;
LLtcnt[16]++;
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
LLtcnt[9]--;
break;
case 4:/* END_SECTION_OPTIONS */
case 10:/* LEXEME_OPTION */
case 11:/* POSITIONING_OPTION_ON */
case 12:/* POSITIONING_OPTION_OFF */
case 16:/* DEFAULT_ACTION_OPTION */
LLtcnt[9]--;
break;
case 9:/* LEXER_OPTION */
LLtcnt[9]--;
LLtcnt[33]++;
LLtcnt[7]++;
LL_SCANDONE(265);/* LEXER_OPTION */
LLread();
LLtcnt[33]--;
LL_SCANDONE(289);/* IDENTIFIER */
#line 35 "parser.g"
{setLexerRoutine(yytext);}
#line 260 "parser.c"
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
}
LL_1:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_1;
LLtcnt[10]--;
break;
case 4:/* END_SECTION_OPTIONS */
case 11:/* POSITIONING_OPTION_ON */
case 12:/* POSITIONING_OPTION_OFF */
case 16:/* DEFAULT_ACTION_OPTION */
LLtcnt[10]--;
break;
case 10:/* LEXEME_OPTION */
LLtcnt[10]--;
LLtcnt[33]++;
LLtcnt[7]++;
LL_SCANDONE(266);/* LEXEME_OPTION */
LLread();
LLtcnt[33]--;
LL_SCANDONE(289);/* IDENTIFIER */
#line 36 "parser.g"
{setLexemeName(yytext);}
#line 288 "parser.c"
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
}
LL_2:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_2;
LLscnt[3]--;
break;
case 4:/* END_SECTION_OPTIONS */
case 16:/* DEFAULT_ACTION_OPTION */
LLscnt[3]--;
break;
case 11:/* POSITIONING_OPTION_ON */
case 12:/* POSITIONING_OPTION_OFF */
LLscnt[3]--;
switch (LLcsymb) {
case 11:/* POSITIONING_OPTION_ON */
LLscnt[4]++;
LLscnt[4]--;
LLtcnt[7]++;
LLtcnt[13]++;
LLtcnt[14]++;
LLtcnt[33]++;
LLtcnt[7]++;
LLtcnt[15]++;
LLtcnt[33]++;
LLtcnt[7]++;
LL_SCANDONE(267);/* POSITIONING_OPTION_ON */
#line 37 "parser.g"
{setPositioningOption(TRUE);}
#line 322 "parser.c"
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
LLtcnt[13]--;
LL_SCANDONE(269);/* WHERE_CLAUSE */
LLread();
LLtcnt[14]--;
LL_SCANDONE(270);/* POSITIONING_LINE */
LLread();
LLtcnt[33]--;
LL_SCANDONE(289);/* IDENTIFIER */
#line 38 "parser.g"
{setPositioningLineName(yytext);}
#line 337 "parser.c"
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
LLtcnt[15]--;
LL_SCANDONE(271);/* POSITIONING_COLUMN */
LLread();
LLtcnt[33]--;
LL_SCANDONE(289);/* IDENTIFIER */
#line 39 "parser.g"
{setPositioningColumneName(yytext);}
#line 349 "parser.c"
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
break;
default:
LLscnt[5]++;
LLscnt[5]--;
LLtcnt[7]++;
LL_SCANDONE(268);/* POSITIONING_OPTION_OFF */
#line 40 "parser.g"
{setPositioningOption(FALSE);}
#line 362 "parser.c"
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
break;
}
}
LL_3:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_3;
LLtcnt[16]--;
break;
case 4:/* END_SECTION_OPTIONS */
LLtcnt[16]--;
break;
case 16:/* DEFAULT_ACTION_OPTION */
LLtcnt[16]--;
LLtcnt[33]++;
LLtcnt[7]++;
LL_SCANDONE(272);/* DEFAULT_ACTION_OPTION */
LLread();
LLtcnt[33]--;
LL_SCANDONE(289);/* IDENTIFIER */
#line 41 "parser.g"
{setDefaultActionRoutineName(yytext);}
#line 389 "parser.c"
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
}
}
static void LL3_DefinesSection(void){
#line 45 "parser.g"
 char *identifier; 
#line 399 "parser.c"
LLtcnt[17]++;
for (;;) {
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
break;
case 5:/* END_SECTION_DEFINES */
break;
case 17:/* DEFINE */
LLtcnt[33]++;
LLtcnt[18]++;
LLtcnt[31]++;
LLscnt[6]++;
LLtcnt[8]++;
LLtcnt[32]++;
LLtcnt[7]++;
LL_SCANDONE(273);/* DEFINE */
LLread();
LLtcnt[33]--;
LL_SCANDONE(289);/* IDENTIFIER */
#line 46 "parser.g"
{ identifier = malloc(sizeof(char) * strlen(yytext)+1); strcpy(identifier, yytext); }
#line 423 "parser.c"
LLread();
LLtcnt[18]--;
LL_SCANDONE(274);/* EQUALS */
LLread();
LLtcnt[31]--;
LL_SCANDONE(287);/* OPEN_BRACES */
LLread();
LL_1:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_1;
/*FALLTHROUGH*/
case 34:/* LITERAL_INT */
LLscnt[6]--;
LL_SCANDONE(290);/* LITERAL_INT */
#line 47 "parser.g"
{addLiteralToDefinition(identifier, yytext);}
#line 442 "parser.c"
break;
case 35:/* LITERAL_CHAR */
LLscnt[6]--;
LL_SCANDONE(291);/* LITERAL_CHAR */
#line 48 "parser.g"
{addLiteralToDefinition(identifier, yytext);}
#line 449 "parser.c"
break;
case 36:/* RANGE_INT */
LLscnt[6]--;
LL_SCANDONE(292);/* RANGE_INT */
#line 49 "parser.g"
{addRangeToDefinition(identifier, yytext);}
#line 456 "parser.c"
break;
case 37:/* RANGE_CHAR */
LLscnt[6]--;
LL_SCANDONE(293);/* RANGE_CHAR */
#line 50 "parser.g"
{addRangeToDefinition(identifier, yytext);}
#line 463 "parser.c"
break;
}
LLread();
for (;;) {
LL_2:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_2;
break;
case 32:/* CLOSE_BRACES */
break;
case 8:/* COMMA */
LLscnt[6]++;
LL_SCANDONE(264);/* COMMA */
LLread();
LL_3:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_3;
/*FALLTHROUGH*/
case 34:/* LITERAL_INT */
LLscnt[6]--;
LL_SCANDONE(290);/* LITERAL_INT */
#line 51 "parser.g"
{addLiteralToDefinition(identifier, yytext);}
#line 490 "parser.c"
break;
case 35:/* LITERAL_CHAR */
LLscnt[6]--;
LL_SCANDONE(291);/* LITERAL_CHAR */
#line 52 "parser.g"
{addLiteralToDefinition(identifier, yytext);}
#line 497 "parser.c"
break;
case 36:/* RANGE_INT */
LLscnt[6]--;
LL_SCANDONE(292);/* RANGE_INT */
#line 53 "parser.g"
{addRangeToDefinition(identifier, yytext);}
#line 504 "parser.c"
break;
case 37:/* RANGE_CHAR */
LLscnt[6]--;
LL_SCANDONE(293);/* RANGE_CHAR */
#line 54 "parser.g"
{addRangeToDefinition(identifier, yytext);}
#line 511 "parser.c"
break;
}
LLread();
continue;
}
LLtcnt[8]--;
break;
}
LLtcnt[32]--;
LL_SCANDONE(288);/* CLOSE_BRACES */
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
continue;
}
LLtcnt[17]--;
break;
}
#line 55 "parser.g"
{free(identifier);}
#line 533 "parser.c"
}
static void LL4_RegExpsSection(void){
LLscnt[2]++;
switch (LLcsymb) {
case 25:/* REGEXP_DEF */
break;
default: LLskip(); break;
}
LLscnt[2]--;
LLtcnt[25]++;
goto LL_0;
for (;;) {
LL_1:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_1;
break;
case 6:/* END_SECTION_REGEXPS */
break;
case 25:/* REGEXP_DEF */
LL_0:
LLscnt[7]++;
LLtcnt[7]++;
LLscnt[8]++;
LLscnt[11]++;
LL_SCANDONE(281);/* REGEXP_DEF */
LLread();
LL_2:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_2;
/*FALLTHROUGH*/
case 26:/* TOKEN_EPSILON */
case 27:/* OPEN_PARENTHESIS */
case 29:/* OPEN_CURLYBRACES */
case 33:/* IDENTIFIER */
case 34:/* LITERAL_INT */
case 35:/* LITERAL_CHAR */
case 38:/* OPERAND */
LLscnt[7]--;
LLscnt[14]++;
LL5_RegularExpressionSet();
break;
case 23:/* REGEXP_EOF */
LLscnt[7]--;
LL_SCANDONE(279);/* REGEXP_EOF */
LLread();
break;
case 24:/* REGEXP_ANYCHAR */
LLscnt[7]--;
LL_SCANDONE(280);/* REGEXP_ANYCHAR */
LLread();
break;
}
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
LL_3:
switch (LLcsymb) {
case 19:/* TOKEN_DEF */
LLscnt[8]--;
LLscnt[9]++;
LLscnt[9]--;
LLtcnt[33]++;
LLtcnt[7]++;
LL_SCANDONE(275);/* TOKEN_DEF */
LLread();
LLtcnt[33]--;
LL_SCANDONE(289);/* IDENTIFIER */
#line 60 "parser.g"
{ addToken(yytext); }
#line 606 "parser.c"
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
break;
default:
if (LLskip())
goto LL_3;
/*FALLTHROUGH*/
case 20:/* NO_TOKEN_DEF */
LLscnt[8]--;
LLscnt[10]++;
LLscnt[10]--;
LLtcnt[7]++;
LL_SCANDONE(276);/* NO_TOKEN_DEF */
#line 60 "parser.g"
{ addNoToken(); }
#line 623 "parser.c"
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
break;
}
#line 61 "parser.g"
{ addDefaultAction(); }
#line 631 "parser.c"
LLread();
LL_4:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_4;
LLscnt[11]--;
break;
case 6:/* END_SECTION_REGEXPS */
case 25:/* REGEXP_DEF */
LLscnt[11]--;
break;
case 21:/* ACTION_DEF */
case 22:/* NO_ACTION_DEF */
LLscnt[11]--;
switch (LLcsymb) {
case 21:/* ACTION_DEF */
LLscnt[12]++;
LLscnt[12]--;
LLtcnt[33]++;
LLtcnt[7]++;
LL_SCANDONE(277);/* ACTION_DEF */
LLread();
LLtcnt[33]--;
LL_SCANDONE(289);/* IDENTIFIER */
#line 61 "parser.g"
{ addAction(yytext); }
#line 658 "parser.c"
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
break;
default:
LLscnt[13]++;
LLscnt[13]--;
LLtcnt[7]++;
LL_SCANDONE(278);/* NO_ACTION_DEF */
#line 61 "parser.g"
{ addNoAction(); }
#line 671 "parser.c"
LLread();
LLtcnt[7]--;
LL_SCANDONE(263);/* SEMICOLON */
LLread();
break;
}
}
continue;
}
LLtcnt[25]--;
break;
}
}
static void LL5_RegularExpressionSet(void){
#line 65 "parser.g"
   RegexTree *rSet;
    RegexTree *new_regex_ptr;
    RegexTree *r;
    RegexTree *tree_ptr; 
#line 691 "parser.c"
LL_0:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 26:/* TOKEN_EPSILON */
case 27:/* OPEN_PARENTHESIS */
case 33:/* IDENTIFIER */
case 34:/* LITERAL_INT */
case 35:/* LITERAL_CHAR */
case 38:/* OPERAND */
LLscnt[14]--;
LLscnt[15]++;
#line 69 "parser.g"
{ r = makeNewRegexTree(); tree_ptr = r; }
#line 708 "parser.c"
LLscnt[15]--;
LL6_RegularExpression
#line 69 "parser.g"
(tree_ptr)
#line 713 "parser.c"
;
#line 69 "parser.g"
{ evaluateRegexTree(r); addTreeToArray(r); }
#line 717 "parser.c"
break;
case 29:/* OPEN_CURLYBRACES */
LLscnt[14]--;
LLscnt[16]++;
LLscnt[16]--;
LLscnt[15]++;
LLtcnt[7]++;
LLtcnt[30]++;
LL_SCANDONE(285);/* OPEN_CURLYBRACES */
#line 70 "parser.g"
{ rSet = makeNewRegexSetTree(); new_regex_ptr = addRegexToRegexSetTree(rSet); }
#line 729 "parser.c"
LLread();
LLscnt[15]--;
LL6_RegularExpression
#line 70 "parser.g"
(new_regex_ptr)
#line 735 "parser.c"
;
for (;;) {
LL_1:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_1;
break;
case 30:/* CLOSE_CURLYBRACES */
break;
case 7:/* SEMICOLON */
LLscnt[15]++;
LL_SCANDONE(263);/* SEMICOLON */
#line 71 "parser.g"
{ new_regex_ptr = addRegexToRegexSetTree(rSet); }
#line 750 "parser.c"
LLread();
LLscnt[15]--;
LL6_RegularExpression
#line 71 "parser.g"
(new_regex_ptr)
#line 756 "parser.c"
;
continue;
}
LLtcnt[7]--;
break;
}
LLtcnt[30]--;
LL_SCANDONE(286);/* CLOSE_CURLYBRACES */
#line 71 "parser.g"
{ evaluateRegexTree(rSet); addTreeToArray(rSet); }
#line 767 "parser.c"
LLread();
break;
}
}
static void LL6_RegularExpression
#line 74 "parser.g"
(RegexTree *node)
#line 775 "parser.c"
{
#line 75 "parser.g"
 RegexTree *child; int operation_type; 
#line 779 "parser.c"
LLtcnt[39]++;
#line 76 "parser.g"
{ child = regexTreeAddTerm(node); }
#line 783 "parser.c"
LL7_Term
#line 76 "parser.g"
(child)
#line 787 "parser.c"
;
for (;;) {
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
break;
case 7:/* SEMICOLON */
case 28:/* CLOSE_PARENTHESIS */
case 30:/* CLOSE_CURLYBRACES */
break;
case 39:/* BINARYOP */
LLscnt[17]++;
LL_SCANDONE(295);/* BINARYOP */
#line 77 "parser.g"
{ operation_type = parseOperationsToType(yytext); regexTreeAddBinary(node, operation_type); }
#line 804 "parser.c"
#line 77 "parser.g"
{ child = regexTreeAddTerm(node); }
#line 807 "parser.c"
LLread();
LLscnt[17]--;
LL7_Term
#line 77 "parser.g"
(child)
#line 813 "parser.c"
;
continue;
}
LLtcnt[39]--;
break;
}
}
static void LL7_Term
#line 80 "parser.g"
(RegexTree *node)
#line 824 "parser.c"
{
#line 81 "parser.g"
 RegexTree *child; int operation_type; 
#line 828 "parser.c"
LLscnt[18]++;
LLtcnt[40]++;
#line 82 "parser.g"
{ child = regexTreeAddFactor(node); }
#line 833 "parser.c"
LL8_Factor
#line 82 "parser.g"
(child)
#line 837 "parser.c"
;
LLread();
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
LLtcnt[40]--;
break;
case 7:/* SEMICOLON */
case 28:/* CLOSE_PARENTHESIS */
case 30:/* CLOSE_CURLYBRACES */
case 39:/* BINARYOP */
LLtcnt[40]--;
break;
case 40:/* UNARYOP */
LLtcnt[40]--;
LL_SCANDONE(296);/* UNARYOP */
#line 82 "parser.g"
{ operation_type = parseOperationsToType(yytext); regexTreeAddUnary(node, operation_type); }
#line 857 "parser.c"
LLread();
}
}
static void LL8_Factor
#line 85 "parser.g"
(RegexTree *node)
#line 864 "parser.c"
{
#line 86 "parser.g"
 RegexTree *child; 
#line 868 "parser.c"
LL_0:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 26:/* TOKEN_EPSILON */
case 33:/* IDENTIFIER */
case 34:/* LITERAL_INT */
case 35:/* LITERAL_CHAR */
case 38:/* OPERAND */
LLscnt[18]--;
LLscnt[19]++;
LL_1:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_1;
/*FALLTHROUGH*/
case 38:/* OPERAND */
LLscnt[19]--;
LL_SCANDONE(294);/* OPERAND */
break;
case 35:/* LITERAL_CHAR */
LLscnt[19]--;
LL_SCANDONE(291);/* LITERAL_CHAR */
break;
case 34:/* LITERAL_INT */
LLscnt[19]--;
LL_SCANDONE(290);/* LITERAL_INT */
break;
case 33:/* IDENTIFIER */
LLscnt[19]--;
LL_SCANDONE(289);/* IDENTIFIER */
break;
case 26:/* TOKEN_EPSILON */
LLscnt[19]--;
LL_SCANDONE(282);/* TOKEN_EPSILON */
break;
}
#line 87 "parser.g"
{ regexTreeAddValue(node, yytext); }
#line 911 "parser.c"
break;
case 27:/* OPEN_PARENTHESIS */
LLscnt[18]--;
LLscnt[15]++;
LLtcnt[28]++;
LL_SCANDONE(283);/* OPEN_PARENTHESIS */
#line 88 "parser.g"
{ child = regexTreeAddRegex(node);}
#line 920 "parser.c"
LLread();
LLscnt[15]--;
LL6_RegularExpression
#line 88 "parser.g"
(child)
#line 926 "parser.c"
;
LLtcnt[28]--;
LL_SCANDONE(284);/* CLOSE_PARENTHESIS */
break;
}
}
#line 92 "parser.g"

/*****************************************************************/
/* the following code is copied verbatim in the generated C file */

void LLmessage(int token) {
    printf("\nSyntax error around \"%s\" on line %d. Aborting...\n", yytext, line);
    exit(-1);
}

int main() {
    LLparser();
    return 0;
}

/*****************************************************************/

#line 950 "parser.c"
void LLparser(void) {
	memset(LLscnt, 0, LL_NSETS * sizeof(int));
	memset(LLtcnt, 0, LL_NTERMINALS * sizeof(int));
	LLtcnt[0]++;
	LLsymb = 0;
	LLreissue = -2 /* LL_NEW_TOKEN */;
	LLread();
	LL0_Input();
	LLread();
	if (LLcsymb != 0) LLerror(256 /* EOFILE*/);
}

