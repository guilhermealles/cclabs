/* THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY LLnextgen. DO NOT EDIT */
#define LL_NTERMINALS 41
#define LL_NSETS 13
#define LL_SSETS 8
#define LLinset(LLx) (LLsets[LLx*LL_SSETS + (LLcsymb/8)] & (1<<(LLcsymb & 7)))
#define LL_SCANDONE(LLx) if (LLsymb != LLx) LLerror(LLx);
static int *LLscnt, *LLtcnt;
static int LLcsymb;
#include <string.h>
static const char LLsets[] = {
	'\x02', 	'\x07', 	'\xBE', 	'\x0F', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x02', 	'\x01', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x4A', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x90', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x02', 	'\x00', 	'\x00', 	'\x00', 	'\x02', 	'\x00', 	'\x00', 	'\x00', 
	'\x2E', 	'\xD0', 	'\x21', 	'\x30', 	'\xB2', 	'\x01', 	'\x00', 	'\x00', 
	'\x2E', 	'\xD0', 	'\x21', 	'\x30', 	'\xA2', 	'\x01', 	'\x00', 	'\x00', 
	'\x00', 	'\xD0', 	'\x01', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x2E', 	'\x00', 	'\x20', 	'\x30', 	'\xA2', 	'\x01', 	'\x00', 	'\x00', 
	'\x04', 	'\x00', 	'\x00', 	'\x20', 	'\x82', 	'\x01', 	'\x00', 	'\x00', 
	'\x2A', 	'\x00', 	'\x20', 	'\x10', 	'\x20', 	'\x00', 	'\x00', 	'\x00', 
	'\x00', 	'\x28', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x00', 
	'\x00', 	'\x00', 	'\x00', 	'\x00', 	'\x82', 	'\x00', 	'\x00', 	'\x00', 
	0
};
static const int LLindex[] = { 0,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   33,   39,   30,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   35,   31,   32,   -1,   34,   40,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   37,   -1,   38,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   36,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
	   0,    1,    2,    3,    4,    5,    6,    7,
	   8,    9,   10,   11,   12,   13,   14,   15,
	  16,   17,   18,   19,   20,   21,   22,   23,
	  24,   25,   26,   27,   28,   29};
int LLsymb;
int LLreissue;
int lexerWrapper(void);
void LLmessage(int);
static void LLread(void) { LLcsymb = LLindex[(LLsymb = lexerWrapper()) + 1]; }
static int LLskip(void) {
	int LL_i;
	if (LLcsymb >= 0) {
		if (LLtcnt[LLcsymb] != 0) return 0;
		for (LL_i = 0; LL_i < LL_NSETS; LL_i++)
			if (LLscnt[LL_i] != 0 && LLinset(LL_i))
				return 0;
	}

	for (;;) {
		LLmessage(-2 /* LL_DELETE */);
		while ((LLcsymb = LLindex[(LLsymb = lexerWrapper()) + 1]) < 0) LLmessage(-2 /* LL_DELETE */);
		if (LLtcnt[LLcsymb] != 0)
			return 1;
		for (LL_i = 0; LL_i < LL_NSETS; LL_i++)
			if (LLscnt[LL_i] != 0 && LLinset(LL_i))
				return 1;
	}
}
static void LLerror(int LLtoken) {
	if (LLtoken == 256 /* EOFILE */) {
		LLmessage(-1 /* LL_MISSINGEOF */);
		while (LLindex[(LLsymb = lexerWrapper()) + 1] != 0) /*NOTHING*/ ;
		return;
	}
	LLtcnt[LLindex[LLtoken + 1]]++;
	LLskip();
	LLtcnt[LLindex[LLtoken + 1]]--;
	if (LLsymb != LLtoken) { LLreissue = LLsymb; LLmessage(LLtoken); }
}
static const char *LLsymbolTable[] = {
"<EOF>", 
"<NUL>", "<SOH>", "<STX>", "<ETX>", 
"<EOT>", "<ENQ>", "<ACK>", "<BEL>", 
"<BS>", "<TAB>", "<NL>", "<VT>", 
"<FF>", "<CR>", "<SO>", "<SI>", 
"<DLE>", "<DC1>", "<DC2>", "<DC3>", 
"<DC4>", "<NAK>", "<SYN>", "<ETB>", 
"<CAN>", "<EM>", "<SUB>", "<ESC>", 
"<FS>", "<GS>", "<RS>", "<US>", 
"<SP>", "'!'", "'\"'", "'#'", 
"'$'", "'%'", "'&'", "'\''", 
"'('", "')'", "'*'", "'+'", 
"','", "'-'", "'.'", "'/'", 
"'0'", "'1'", "'2'", "'3'", 
"'4'", "'5'", "'6'", "'7'", 
"'8'", "'9'", "':'", "';'", 
"'<'", "'='", "'>'", "'?'", 
"'@'", "'A'", "'B'", "'C'", 
"'D'", "'E'", "'F'", "'G'", 
"'H'", "'I'", "'J'", "'K'", 
"'L'", "'M'", "'N'", "'O'", 
"'P'", "'Q'", "'R'", "'S'", 
"'T'", "'U'", "'V'", "'W'", 
"'X'", "'Y'", "'Z'", "'['", 
"'\\'", "']'", "'^'", "'_'", 
"'`'", "'a'", "'b'", "'c'", 
"'d'", "'e'", "'f'", "'g'", 
"'h'", "'i'", "'j'", "'k'", 
"'l'", "'m'", "'n'", "'o'", 
"'p'", "'q'", "'r'", "'s'", 
"'t'", "'u'", "'v'", "'w'", 
"'x'", "'y'", "'z'", "'{'", 
"'|'", "'}'", "'~'", "<DEL>", 
"'\x80'", "'\x81'", "'\x82'", "'\x83'", 
"'\x84'", "'\x85'", "'\x86'", "'\x87'", 
"'\x88'", "'\x89'", "'\x8A'", "'\x8B'", 
"'\x8C'", "'\x8D'", "'\x8E'", "'\x8F'", 
"'\x90'", "'\x91'", "'\x92'", "'\x93'", 
"'\x94'", "'\x95'", "'\x96'", "'\x97'", 
"'\x98'", "'\x99'", "'\x9A'", "'\x9B'", 
"'\x9C'", "'\x9D'", "'\x9E'", "'\x9F'", 
"'\xA0'", "'\xA1'", "'\xA2'", "'\xA3'", 
"'\xA4'", "'\xA5'", "'\xA6'", "'\xA7'", 
"'\xA8'", "'\xA9'", "'\xAA'", "'\xAB'", 
"'\xAC'", "'\xAD'", "'\xAE'", "'\xAF'", 
"'\xB0'", "'\xB1'", "'\xB2'", "'\xB3'", 
"'\xB4'", "'\xB5'", "'\xB6'", "'\xB7'", 
"'\xB8'", "'\xB9'", "'\xBA'", "'\xBB'", 
"'\xBC'", "'\xBD'", "'\xBE'", "'\xBF'", 
"'\xC0'", "'\xC1'", "'\xC2'", "'\xC3'", 
"'\xC4'", "'\xC5'", "'\xC6'", "'\xC7'", 
"'\xC8'", "'\xC9'", "'\xCA'", "'\xCB'", 
"'\xCC'", "'\xCD'", "'\xCE'", "'\xCF'", 
"'\xD0'", "'\xD1'", "'\xD2'", "'\xD3'", 
"'\xD4'", "'\xD5'", "'\xD6'", "'\xD7'", 
"'\xD8'", "'\xD9'", "'\xDA'", "'\xDB'", 
"'\xDC'", "'\xDD'", "'\xDE'", "'\xDF'", 
"'\xE0'", "'\xE1'", "'\xE2'", "'\xE3'", 
"'\xE4'", "'\xE5'", "'\xE6'", "'\xE7'", 
"'\xE8'", "'\xE9'", "'\xEA'", "'\xEB'", 
"'\xEC'", "'\xED'", "'\xEE'", "'\xEF'", 
"'\xF0'", "'\xF1'", "'\xF2'", "'\xF3'", 
"'\xF4'", "'\xF5'", "'\xF6'", "'\xF7'", 
"'\xF8'", "'\xF9'", "'\xFA'", "'\xFB'", 
"'\xFC'", "'\xFD'", "'\xFE'", "'\xFF'", 
"<EOF>", "identifier", "number", "literal", 
"string", "literal, identifier or term", "literal or identifier", "string", 
"identifier", "%token", "%start", "%persistent", 
"%if", "%while", "%avoid", "%prefer", 
"%default", "%lexical", "%prefix", "%onerror", 
"%first", "C code", "C expression", "%label", 
"%include", "%options", "%datatype", "%top", 
"...", "..?"};
const char *LLgetSymbol(int LLtoken) {
	if (LLtoken < -1 || LLtoken > 285 /* == LL_MAXTOKNO */)
		return (char *) 0;
	return LLsymbolTable[LLtoken+1];
}
#include "grammar.h"
#line 18 "grammar.g"
  /* start of C code */
#include <errno.h>
#include <stdlib.h>
#include <limits.h>

#include "posixregex.h"

#include "nonRuleAnalysis.h"
#include "ruleAnalysis.h"
#include "globals.h"
#include "argcount.h"
#include "option.h"
#include "localOptionMacros.h"
#include "lexer.h"
#include "bool.h"

/** Function required by parser to show error messages.
	@param symb A symbol to be inserted or a value indicating the deletion of
		tokens.
*/
void LLmessage(int symb) {
	switch (symb) {
		case LL_MISSINGEOF:
			error(NULL, "Unexpected %s", LLgetSymbol(LLsymb));
			break;
		case LL_DELETE:
			error(NULL, "Unexpected %s", LLgetSymbol(LLsymb));
			break;
		default:
			error(NULL, "Expected %s before %s", LLgetSymbol(symb), LLgetSymbol(LLsymb));
			break;
	}
	switch (LLsymb) {
		case IDENTIFIER:
		case NUMBER:
		case LITERAL:
		case STRING:
			continueMessage(" %s", yytext);
			break;
		default:
			break;
	}
	endMessage();
}


#line 226 "grammar.c"
static void LL0_specification(void);
static Token * LL1_identifier(void);
static void LL2_declaration(void);
static void LL3_rule(void);
static void LL4_productions
#line 558 "grammar.g"
(Term *term)
#line 234 "grammar.c"
;
static void LL5_simpleproduction
#line 579 "grammar.g"
(Alternative *alternative)
#line 239 "grammar.c"
;
static GrammarPart * LL6_element(void);
static Repeats LL7_repeats(void);
static void LL0_specification(void){
LLscnt[0]++;
for (;;) {
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
break;
case 0:/* <NUL> */
break;
case 1:/* IDENTIFIER */
case 8:/* MISSING_IDENTIFIER */
case 9:/* TOKEN */
case 10:/* START */
case 17:/* LEXICAL */
case 18:/* PREFIX */
case 19:/* ONERROR */
case 20:/* FIRST */
case 21:/* C_DECL */
case 23:/* LABEL */
case 24:/* INCLUDE */
case 25:/* OPTIONS */
case 26:/* DATATYPE */
case 27:/* TOP */
LLscnt[0]++;
LL2_declaration();
LLread();
continue;
}
LLscnt[0]--;
break;
}
}
static Token * LL1_identifier(void){
#line 100 "grammar.g"
Token *
#line 279 "grammar.c"
LLretval;
memset(&LLretval, 0, sizeof(LLretval));
{
LL_0:
switch (LLcsymb) {
case 1:/* IDENTIFIER */
LLscnt[1]--;
LL_SCANDONE(257);/* IDENTIFIER */
#line 102 "grammar.g"
{
		LLretval = newToken();
	}
#line 292 "grammar.c"
break;
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 8:/* MISSING_IDENTIFIER */
LLscnt[1]--;
LL_SCANDONE(264);/* MISSING_IDENTIFIER */
break;
}
}
return LLretval;
}
static void LL2_declaration(void){
#line 100 "grammar.g"
Token *
#line 309 "grammar.c"
identifier;
#line 100 "grammar.g"
Token *
#line 313 "grammar.c"
secondIdentifier;
memset(&identifier, 0, sizeof(identifier));
memset(&secondIdentifier, 0, sizeof(secondIdentifier));
{
#line 111 "grammar.g"

	identifier = NULL;
	secondIdentifier = NULL;

#line 323 "grammar.c"
LL_0:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 21:/* C_DECL */
LLscnt[0]--;
LL_SCANDONE(277);/* C_DECL */
#line 116 "grammar.g"
{
		CCode *code = newCCode();
		newDeclaration(CODE, code);
	}
#line 338 "grammar.c"
break;
case 10:/* START */
LLscnt[0]--;
LLscnt[1]++;
LLtcnt[30]++;
LLscnt[1]++;
LLtcnt[31]++;
LL_SCANDONE(266);/* START */
LLread();
identifier = LL1_identifier();
LLread();
LLtcnt[30]--;
LL_SCANDONE(44);/* ',' */
LLread();
secondIdentifier = LL1_identifier();
#line 125 "grammar.g"
{
		if (identifier != NULL && secondIdentifier != NULL) {
			Directive *directive = newDirective(START_DIRECTIVE, identifier, secondIdentifier);
			newDeclaration(DIRECTIVE, directive);
		} else {
			freeToken(identifier);
			freeToken(secondIdentifier);
		}
	}
#line 364 "grammar.c"
LLread();
LLtcnt[31]--;
LL_SCANDONE(59);/* ';' */
break;
case 9:/* TOKEN */
LLscnt[0]--;
LLscnt[1]++;
LLtcnt[30]++;
LLtcnt[31]++;
LL_SCANDONE(265);/* TOKEN */
LLread();
identifier = LL1_identifier();
#line 138 "grammar.g"
{
		if (identifier != NULL) {
			Directive *directive = newDirective(TOKEN_DIRECTIVE, identifier, NULL);
			newDeclaration(DIRECTIVE, directive);
			identifier = NULL;
		}
	}
#line 385 "grammar.c"
LLread();
for (;;) {
LL_1:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_1;
break;
case 31:/* ';' */
break;
case 30:/* ',' */
LLscnt[1]++;
LL_SCANDONE(44);/* ',' */
LLread();
identifier = LL1_identifier();
#line 148 "grammar.g"
{
			if (identifier != NULL) {
				Directive *directive = newDirective(TOKEN_DIRECTIVE, identifier, NULL);
				newDeclaration(DIRECTIVE, directive);
				identifier = NULL;
			}
		}
#line 408 "grammar.c"
LLread();
continue;
}
LLtcnt[30]--;
break;
}
LLtcnt[31]--;
LL_SCANDONE(59);/* ';' */
break;
case 20:/* FIRST */
LLscnt[0]--;
LLscnt[1]++;
LLtcnt[30]++;
LLscnt[1]++;
LLtcnt[31]++;
LL_SCANDONE(276);/* FIRST */
LLread();
identifier = LL1_identifier();
LLread();
LLtcnt[30]--;
LL_SCANDONE(44);/* ',' */
LLread();
secondIdentifier = LL1_identifier();
#line 162 "grammar.g"
{
		if (identifier != NULL && secondIdentifier != NULL) {
			Directive *directive = newDirective(FIRST_DIRECTIVE, identifier, secondIdentifier);
			newDeclaration(DIRECTIVE, directive);
		} else {
			freeToken(identifier);
			freeToken(secondIdentifier);
		}
	}
#line 442 "grammar.c"
LLread();
LLtcnt[31]--;
LL_SCANDONE(59);/* ';' */
break;
case 17:/* LEXICAL */
LLscnt[0]--;
LLscnt[1]++;
LLtcnt[31]++;
LL_SCANDONE(273);/* LEXICAL */
LLread();
identifier = LL1_identifier();
#line 175 "grammar.g"
{
		if (identifier != NULL) {
			Directive *directive = newDirective(LEXICAL_DIRECTIVE, identifier, NULL);
			newDeclaration(DIRECTIVE, directive);
		}
	}
#line 461 "grammar.c"
LLread();
LLtcnt[31]--;
LL_SCANDONE(59);/* ';' */
break;
case 18:/* PREFIX */
LLscnt[0]--;
LLscnt[1]++;
LLtcnt[31]++;
LL_SCANDONE(274);/* PREFIX */
LLread();
identifier = LL1_identifier();
#line 185 "grammar.g"
{
		if (identifier != NULL) {
			Directive *directive = newDirective(PREFIX_DIRECTIVE, identifier, NULL);
			newDeclaration(DIRECTIVE, directive);
		}
	}
#line 480 "grammar.c"
LLread();
LLtcnt[31]--;
LL_SCANDONE(59);/* ';' */
break;
case 19:/* ONERROR */
LLscnt[0]--;
LLscnt[1]++;
LLtcnt[31]++;
LL_SCANDONE(275);/* ONERROR */
LLread();
identifier = LL1_identifier();
#line 195 "grammar.g"
{
		if (identifier != NULL) {
			Directive *directive = newDirective(ONERROR_DIRECTIVE, identifier, NULL);
			newDeclaration(DIRECTIVE, directive);
		}
		error(NULL, "%%onerror not supported (yet)\n");
	}
#line 500 "grammar.c"
LLread();
LLtcnt[31]--;
LL_SCANDONE(59);/* ';' */
break;
case 23:/* LABEL */
LLscnt[0]--;
LLscnt[2]++;
LLtcnt[30]++;
LLscnt[3]++;
LLtcnt[31]++;
LL_SCANDONE(279);/* LABEL */
LLread();
LL_2:
switch (LLcsymb) {
case 1:/* IDENTIFIER */
LLscnt[2]--;
LL_SCANDONE(257);/* IDENTIFIER */
#line 207 "grammar.g"
{
			if (!option.llgenMode)
				identifier = newToken();
		}
#line 523 "grammar.c"
break;
case 3:/* LITERAL */
LLscnt[2]--;
LL_SCANDONE(259);/* LITERAL */
#line 213 "grammar.g"
{
			if (!option.llgenMode)
				identifier = newToken();
		}
#line 533 "grammar.c"
break;
default:
if (LLskip())
goto LL_2;
/*FALLTHROUGH*/
case 6:/* MISSING_LITERAL_OR_IDENTIFIER */
LLscnt[2]--;
LL_SCANDONE(262);/* MISSING_LITERAL_OR_IDENTIFIER */
break;
}
LLread();
LLtcnt[30]--;
LL_SCANDONE(44);/* ',' */
LLread();
LL_3:
switch (LLcsymb) {
case 4:/* STRING */
LLscnt[3]--;
LL_SCANDONE(260);/* STRING */
#line 224 "grammar.g"
{
			if (!option.llgenMode)
				secondIdentifier = newToken();
		}
#line 558 "grammar.c"
break;
default:
if (LLskip())
goto LL_3;
/*FALLTHROUGH*/
case 7:/* MISSING_STRING */
LLscnt[3]--;
LL_SCANDONE(263);/* MISSING_STRING */
break;
}
#line 232 "grammar.g"
{
		if (option.llgenMode) {
			error(NULL, "%%label is not allowed in LLgen mode\n");
			freeToken(identifier);
			freeToken(secondIdentifier);
		} else if (identifier != NULL && secondIdentifier != NULL) {
			Directive *directive = newDirective(LABEL_DIRECTIVE, identifier, secondIdentifier);
			newDeclaration(DIRECTIVE, directive);
		} else {
			freeToken(identifier);
			freeToken(secondIdentifier);
		}
	}
#line 583 "grammar.c"
LLread();
LLtcnt[31]--;
LL_SCANDONE(59);/* ';' */
break;
case 24:/* INCLUDE */
LLscnt[0]--;
LLscnt[3]++;
LLtcnt[31]++;
LL_SCANDONE(280);/* INCLUDE */
LLread();
LL_4:
switch (LLcsymb) {
case 4:/* STRING */
LLscnt[3]--;
LL_SCANDONE(260);/* STRING */
#line 250 "grammar.g"
{
			if (!(option.llgenMode || option.LLgenStyleOutputs)) {
				identifier = newToken();
			}
		}
#line 605 "grammar.c"
break;
default:
if (LLskip())
goto LL_4;
/*FALLTHROUGH*/
case 7:/* MISSING_STRING */
LLscnt[3]--;
LL_SCANDONE(263);/* MISSING_STRING */
break;
}
LLread();
LLtcnt[31]--;
LL_SCANDONE(59);/* ';' */
#line 260 "grammar.g"
{
		if (option.llgenMode) {
			error(NULL, "%%include is not allowed in LLgen mode\n");
		} else if (option.LLgenStyleOutputs) {
			error(NULL, "%%include is not allowed with LLgen-style outputs\n");
		} else if (identifier != NULL) {
			if (openInclude(identifier))
				parser();
			freeToken(identifier);
		}
	}
#line 631 "grammar.c"
break;
case 25:/* OPTIONS */
LLscnt[0]--;
LLscnt[3]++;
LLtcnt[31]++;
LL_SCANDONE(281);/* OPTIONS */
LLread();
LL_5:
switch (LLcsymb) {
case 4:/* STRING */
LLscnt[3]--;
LL_SCANDONE(260);/* STRING */
#line 275 "grammar.g"
{
			if (!option.llgenMode)
				identifier = newToken();
		}
#line 649 "grammar.c"
break;
default:
if (LLskip())
goto LL_5;
/*FALLTHROUGH*/
case 7:/* MISSING_STRING */
LLscnt[3]--;
LL_SCANDONE(263);/* MISSING_STRING */
break;
}
LLread();
LLtcnt[31]--;
LL_SCANDONE(59);/* ';' */
#line 284 "grammar.g"
{

		/* Most options will override the command line, except for:
			--base-name
			--error-limit
			--verbose
			--token-pattern
		*/
		if (option.llgenMode) {
			error(NULL, "%%options is not allowed in LLgen mode\n");
		} else if (identifier != NULL) {
			/* NOTE: this name is fixed, as all the macro's below use it! */
			char *optstring;

			char *strtokState;
			char *processedString = processString(identifier);

			if (processedString == NULL) {
				warning(WARNING_UNMASKED, identifier, "Error parsing %%options string\n");
			} else if ((optstring = strtokReentrant(processedString, " \t\n", &strtokState)) != NULL) {
				bool nonSupported = false;
				do {
					PREPROCESS_OPTION()

					LOCAL_OPTION("verbose", OPTIONAL_ARG)
						if (!option.verboseSet) {
							if (optarg != NULL) {
								PARSE_INT(option.verbose, 1, MAX_VERBOSITY);
							} else {
								option.verbose++;
								/* Prevent overflow */
								if (option.verbose > MAX_VERBOSITY)
									option.verbose = MAX_VERBOSITY;
							}
						} else {
							warning(WARNING_OPTION_OVERRIDE, identifier, "Will not override verbose option passed on command line\n");
						}
					LOCAL_END_OPTION
					LOCAL_OPTION("suppress-warnings", OPTIONAL_ARG)
						checkWarningSuppressionArguments(optarg, (int) optlength, optstring);
					LOCAL_END_OPTION

					LOCAL_OPTION("max-compatibility", NO_ARG)
						option.LLgenArgStyle = true;
						option.onlyLLgenEscapes = true;
						option.LLgenStyleOutputs = true;
					LOCAL_END_OPTION
					LOCAL_BOOLEAN_OPTION("warnings-as-errors", option.warningsErrors)
					LOCAL_OPTION("base-name", REQUIRED_ARG)
						if (!option.outputBaseNameSet) {
							option.outputBaseName = safeStrdup(optarg, "parseCmdLine");
							option.outputBaseNameSet = true;
							option.outputBaseNameLocation = newPlaceHolder();
						} else {
							if (option.outputBaseNameLocation == NULL) {
								warning(WARNING_OPTION_OVERRIDE, identifier, "Will not override base-name option passed on command line\n");
							} else {
								warning(WARNING_UNMASKED, identifier, "Option base-name already set at ");
								printAt(option.outputBaseNameLocation);
								continueMessage("\n");
							}
						}
					LOCAL_END_OPTION
					LOCAL_OPTION("extensions", REQUIRED_ARG)
						if (option.extensions == NULL) {
							option.extensions = split(optarg, ",", true);
							option.extensionsLocation = newPlaceHolder();
						} else {
							if (option.extensionsLocation == NULL) {
								warning(WARNING_OPTION_OVERRIDE, identifier, "Will not override extensions option passed on command line\n");
							} else {
								warning(WARNING_UNMASKED, identifier, "Option extensions already set at ");
								printAt(option.extensionsLocation);
								continueMessage("\n");
							}
						}
					LOCAL_END_OPTION
					LOCAL_BOOLEAN_OPTION("llgen-arg-style", option.LLgenArgStyle)
					LOCAL_BOOLEAN_OPTION("llgen-escapes-only", option.onlyLLgenEscapes)
					LOCAL_BOOLEAN_OPTION("no-prototypes-header", option.noPrototypesHeader)
					LOCAL_BOOLEAN_OPTION("no-line-directives", option.dontGenerateLineDirectives)
					LOCAL_BOOLEAN_OPTION("llgen-output-style", option.LLgenStyleOutputs)
					LOCAL_BOOLEAN_OPTION("reentrant", option.reentrant)
					LOCAL_BOOLEAN_OPTION("no-eof-zero", option.noEOFZero)
					LOCAL_BOOLEAN_OPTION("no-init-llretval", option.noInitLLretval)
					LOCAL_BOOLEAN_OPTION("no-llreissue", option.noLLreissue)
					LOCAL_OPTION("generate-lexer-wrapper", OPTIONAL_ARG)
						if (option.generateLexerWrapperSpecified) {
							if (option.generateLexerWrapperLocation == NULL) {
								warning(WARNING_UNMASKED, identifier, "Option generate-lexer-wrapper also set on command line\n");
							} else {
								warning(WARNING_UNMASKED, identifier, "Option generate-lexer-wrapper also set at ");
								printAt(option.generateLexerWrapperLocation);
								continueMessage("\n");
							}
						}
						option.generateLexerWrapperSpecified = true;
						option.generateLexerWrapperLocation = newPlaceHolder();
						if (optarg == NULL) {
							option.generateLexerWrapper = true;
						} else {
							if (strcmp(optarg, "no") == 0)
								option.generateLexerWrapper = false;
							else if (strcmp(optarg, "yes") == 0)
								option.generateLexerWrapper = true;
							else
								fatal("Argument '%s' is invalid for option generate-lexer-wrapper\n", optarg);
						}
					LOCAL_END_OPTION
					LOCAL_BOOLEAN_OPTION("generate-llmessage", option.generateLLmessage)
					LOCAL_BOOLEAN_OPTION("generate-symbol-table", option.generateSymbolTable)
					LOCAL_BOOLEAN_OPTION("abort", option.abort)
					LOCAL_BOOLEAN_OPTION("no-allow-label-create", option.noAllowLabelCreate)
					LOCAL_OPTION("error-limit", REQUIRED_ARG)
						if (!option.errorLimitSet)
							PARSE_INT(option.errorLimit, 0, INT_MAX);
						else
							warning(WARNING_OPTION_OVERRIDE, identifier, "Will not override error-limit option passed on the command line\n");
					LOCAL_END_OPTION
					LOCAL_BOOLEAN_OPTION("no-arg-count", option.noArgCount);
					LOCAL_BOOLEAN_OPTION("lowercase-symbols", option.lowercaseSymbols);
					LOCAL_BOOLEAN_OPTION("not-only-reachable", option.notOnlyReachable);
					LOCAL_BOOLEAN_OPTION("thread-safe", option.threadSafe)
#ifdef USE_REGEX
					LOCAL_OPTION("token-pattern", REQUIRED_ARG)
						int result;
						if (!option.useTokenPattern) {
							option.useTokenPattern = true;
							if ((result = regcomp(&option.tokenPattern, optarg, REG_EXTENDED | REG_NOSUB)) != 0) {
								char errorBuffer[100];
								regerror(result, &option.tokenPattern, errorBuffer, 100);
								fatal("Regular expression could not be compiled: %s\n", errorBuffer);
							}
						} else {
							warning(WARNING_OPTION_OVERRIDE, identifier, "Will not override token-pattern specified on the command line\n");
						}
					LOCAL_END_OPTION
#else
					LOCAL_OPTION("token-pattern", OPTIONAL_ARG)
						fatal("This LLnextgen binary does not support the '%.*s' option. See the documentation for details\n", (int) optlength, optstring);
					LOCAL_END_OPTION
#endif
					LOCAL_OPTION("gettext", OPTIONAL_ARG)
						checkGettextArguments(optarg);
					LOCAL_END_OPTION

					/* Show appropriate message for options only supported on command line */
					LOCAL_OPTION_USED("depend", nonSupported)
					LOCAL_OPTION_USED("depend-cpp", nonSupported)
					LOCAL_OPTION_USED("dump-lexer-wrapper", nonSupported)
					LOCAL_OPTION_USED("dump-llmessage", nonSupported)
					LOCAL_OPTION_USED("dump-tokens", nonSupported)
					LOCAL_OPTION_USED("help", nonSupported)
					LOCAL_OPTION_USED("keep-dir", nonSupported)
					LOCAL_OPTION_USED("show-dir", nonSupported)
					LOCAL_OPTION_USED("version", nonSupported)

					if (nonSupported)
						fatal("Option '%.*s' is not supported in %%options\n", (int) optlength, optstring);

					error(identifier, "Option '%.*s' does not exist\n", (int) optlength, optstring);
				} while ((optstring = strtokReentrant(NULL, " \t\n", &strtokState)) != NULL);

				/* After this point, the string will not be used anymore. */
				free(processedString);

				postOptionChecks();
			}
			/* After this point, the identifier will not be used anymore. */
			freeToken(identifier);
		}
	}
#line 836 "grammar.c"
break;
case 26:/* DATATYPE */
LLscnt[0]--;
LLscnt[3]++;
LLtcnt[30]++;
LLtcnt[31]++;
LL_SCANDONE(282);/* DATATYPE */
LLread();
LL_6:
switch (LLcsymb) {
case 4:/* STRING */
LLscnt[3]--;
LL_SCANDONE(260);/* STRING */
#line 460 "grammar.g"
{
			if (!option.llgenMode)
				identifier = newToken();
		}
#line 855 "grammar.c"
break;
default:
if (LLskip())
goto LL_6;
/*FALLTHROUGH*/
case 7:/* MISSING_STRING */
LLscnt[3]--;
LL_SCANDONE(263);/* MISSING_STRING */
break;
}
LLread();
LL_7:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_7;
LLtcnt[30]--;
break;
case 31:/* ';' */
LLtcnt[30]--;
break;
case 30:/* ',' */
LLtcnt[30]--;
LLscnt[3]++;
LL_SCANDONE(44);/* ',' */
LLread();
LL_8:
switch (LLcsymb) {
case 4:/* STRING */
LLscnt[3]--;
LL_SCANDONE(260);/* STRING */
#line 472 "grammar.g"
{
				if (!option.llgenMode)
					secondIdentifier = newToken();
			}
#line 891 "grammar.c"
break;
default:
if (LLskip())
goto LL_8;
/*FALLTHROUGH*/
case 7:/* MISSING_STRING */
LLscnt[3]--;
LL_SCANDONE(263);/* MISSING_STRING */
break;
}
LLread();
}
LLtcnt[31]--;
LL_SCANDONE(59);/* ';' */
#line 482 "grammar.g"
{
		if (option.llgenMode) {
			error(NULL, "%%datatype is not allowed in LLgen mode\n");
		} else {
			Directive *directive = newDirective(DATATYPE_DIRECTIVE, identifier, secondIdentifier);
			newDeclaration(DIRECTIVE, directive);
		}
	}
#line 915 "grammar.c"
break;
case 27:/* TOP */
LLscnt[0]--;
LLtcnt[21]++;
LL_SCANDONE(283);/* TOP */
LLread();
LLtcnt[21]--;
LL_SCANDONE(277);/* C_DECL */
#line 493 "grammar.g"
{
		if (top_code != NULL)
			error(NULL, "Only one section of C code may be marked with %%top\n");
		else if (option.llgenMode)
			error(NULL, "%%top is not supported in LLgen mode\n");
		else
			top_code = newCCode();
	}
#line 933 "grammar.c"
break;
case 1:/* IDENTIFIER */
case 8:/* MISSING_IDENTIFIER */
LLscnt[0]--;
LLtcnt[31]++;
LL3_rule();
LLtcnt[31]--;
LL_SCANDONE(59);/* ';' */
break;
}
}
}
static void LL3_rule(void){
#line 100 "grammar.g"
Token *
#line 949 "grammar.c"
retvalIdent;
#line 100 "grammar.g"
Token *
#line 953 "grammar.c"
name;
memset(&retvalIdent, 0, sizeof(retvalIdent));
memset(&name, 0, sizeof(name));
{
#line 506 "grammar.g"

	NonTerminal *nonTerminal;
	CCode *expr = NULL, *decl = NULL;
	List *rule;
	int argCount = 0;

	retvalIdent = NULL;

#line 967 "grammar.c"
LLscnt[1]++;
LLtcnt[32]++;
LLtcnt[22]++;
LLtcnt[21]++;
LLtcnt[35]++;
LLscnt[5]++;
name = LL1_identifier();
LLread();
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
LLtcnt[32]--;
break;
case 21:/* C_DECL */
case 22:/* C_EXPR */
case 35:/* ':' */
LLtcnt[32]--;
break;
case 32:/* '<' */
LLtcnt[32]--;
LLscnt[1]++;
LLscnt[4]++;
LLtcnt[34]++;
LL_SCANDONE(60);/* '<' */
LLread();
retvalIdent = LL1_identifier();
LLread();
for (;;) {
LL_1:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_1;
break;
case 34:/* '>' */
break;
case 1:/* IDENTIFIER */
case 33:/* '*' */
LLscnt[4]++;
LL_2:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_2;
/*FALLTHROUGH*/
case 33:/* '*' */
LLscnt[4]--;
LL_SCANDONE(42);/* '*' */
break;
case 1:/* IDENTIFIER */
LLscnt[4]--;
LL_SCANDONE(257);/* IDENTIFIER */
break;
}
#line 524 "grammar.g"
{
				if (retvalIdent != NULL)
					safeStrcatWithSpace(&retvalIdent->text, yytext, "grammar:rule");
			}
#line 1027 "grammar.c"
LLread();
continue;
}
LLscnt[4]--;
break;
}
LLtcnt[34]--;
LL_SCANDONE(62);/* '>' */
LLread();
}
LL_3:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_3;
LLtcnt[22]--;
break;
case 21:/* C_DECL */
case 35:/* ':' */
LLtcnt[22]--;
break;
case 22:/* C_EXPR */
LLtcnt[22]--;
LL_SCANDONE(278);/* C_EXPR */
#line 533 "grammar.g"
{
			expr = newCCode();
			/* The input may not be completely valid, but we can still do
			   checking without worying about seg-faults and the like. We may
			   generate an extra error message, but that's OK. */
			if (!option.noArgCount)
				argCount = determineArgumentCount(expr, true);
		}
#line 1060 "grammar.c"
LLread();
}
LL_4:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_4;
LLtcnt[21]--;
break;
case 35:/* ':' */
LLtcnt[21]--;
break;
case 21:/* C_DECL */
LLtcnt[21]--;
LL_SCANDONE(277);/* C_DECL */
#line 544 "grammar.g"
{
			decl = newCCode();
		}
#line 1079 "grammar.c"
LLread();
}
LLtcnt[35]--;
LL_SCANDONE(58);/* ':' */
#line 549 "grammar.g"
{
		rule = newList();
		nonTerminal = newNonTerminal(name, retvalIdent, expr, decl, rule, argCount);
		if (name != NULL)
			newDeclaration(NONTERMINAL, nonTerminal);
	}
#line 1091 "grammar.c"
LLread();
LLscnt[5]--;
LL4_productions
#line 555 "grammar.g"
(&nonTerminal->term)
#line 1097 "grammar.c"
;
}
}
static void LL4_productions
#line 558 "grammar.g"
(Term *term)
#line 1104 "grammar.c"
{
#line 559 "grammar.g"

	Alternative *alternative;

#line 1110 "grammar.c"
LLtcnt[36]++;
#line 562 "grammar.g"
{
		alternative = newAlternative();
		alternative->enclosing = term;
		listAppend(term->rule, alternative);
	}
#line 1118 "grammar.c"
LL5_simpleproduction
#line 567 "grammar.g"
(alternative)
#line 1122 "grammar.c"
;
for (;;) {
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
break;
case 31:/* ';' */
case 38:/* ']' */
break;
case 36:/* '|' */
LLscnt[6]++;
LL_SCANDONE(124);/* '|' */
#line 570 "grammar.g"
{
			alternative = newAlternative();
			alternative->enclosing = term;
			listAppend(term->rule, alternative);
		}
#line 1142 "grammar.c"
LLread();
LLscnt[6]--;
LL5_simpleproduction
#line 575 "grammar.g"
(alternative)
#line 1148 "grammar.c"
;
continue;
}
LLtcnt[36]--;
break;
}
}
static void LL5_simpleproduction
#line 579 "grammar.g"
(Alternative *alternative)
#line 1159 "grammar.c"
{
#line 652 "grammar.g"
GrammarPart *
#line 1163 "grammar.c"
grammarPart;
#line 731 "grammar.g"
Repeats
#line 1167 "grammar.c"
repeats;
memset(&grammarPart, 0, sizeof(grammarPart));
memset(&repeats, 0, sizeof(repeats));
{
LLscnt[7]++;
LLscnt[8]++;
for (;;) {
LL_0:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_0;
break;
case 1:/* IDENTIFIER */
case 3:/* LITERAL */
case 5:/* MISSING_ELEMENT */
case 21:/* C_DECL */
case 28:/* BACKREF */
case 31:/* ';' */
case 36:/* '|' */
case 37:/* '[' */
case 38:/* ']' */
break;
case 12:/* IF */
case 14:/* AVOID */
case 15:/* PREFER */
case 16:/* DEFAULT */
switch (LLcsymb) {
default:
LL_SCANDONE(272);/* DEFAULT */
#line 582 "grammar.g"
{
			if (alternative->flags & ALTERNATIVE_DEFAULT)
				error(NULL, "%%default specified more than once on a single alternative\n");
			alternative->flags |= ALTERNATIVE_DEFAULT;
		}
#line 1203 "grammar.c"
LLread();
break;
case 12:/* IF */
LLtcnt[22]++;
LL_SCANDONE(268);/* IF */
#line 589 "grammar.g"
{
			if (alternative->flags & ALTERNATIVE_CONDITION)
				error(NULL, "More than one condition specified on a single alternative\n");
			alternative->flags |= ALTERNATIVE_IF;
		}
#line 1215 "grammar.c"
LLread();
LLtcnt[22]--;
LL_SCANDONE(278);/* C_EXPR */
#line 595 "grammar.g"
{
			alternative->expression = newCCode();
		}
#line 1223 "grammar.c"
LLread();
break;
case 15:/* PREFER */
LL_SCANDONE(271);/* PREFER */
#line 600 "grammar.g"
{
			if (alternative->flags & ALTERNATIVE_CONDITION)
				error(NULL, "More than one condition specified on a single alternative\n");
			alternative->flags |= ALTERNATIVE_PREFER;
		}
#line 1234 "grammar.c"
LLread();
break;
case 14:/* AVOID */
LL_SCANDONE(270);/* AVOID */
#line 607 "grammar.g"
{
			if (alternative->flags & ALTERNATIVE_CONDITION)
				error(NULL, "More than one condition specified on a single alternative\n");
			alternative->flags |= ALTERNATIVE_AVOID;
		}
#line 1245 "grammar.c"
LLread();
break;
}
continue;
}
LLscnt[7]--;
break;
}
for (;;) {
LL_1:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_1;
break;
case 31:/* ';' */
case 36:/* '|' */
case 38:/* ']' */
break;
case 1:/* IDENTIFIER */
case 2:/* NUMBER */
case 3:/* LITERAL */
case 5:/* MISSING_ELEMENT */
case 21:/* C_DECL */
case 28:/* BACKREF */
case 29:/* DOTQMARK */
case 33:/* '*' */
case 37:/* '[' */
case 39:/* '+' */
case 40:/* '?' */
LLscnt[10]++;
LLscnt[9]++;
grammarPart = LL6_element();
repeats = LL7_repeats();
#line 617 "grammar.g"
{
			switch (grammarPart->subtype) {
				case PART_ACTION:
					if (repeats.number != 1 || repeats.subtype != FIXED)
						error(grammarPart->uAction, "Repetition specified on action\n");
					break;
				case PART_UNDETERMINED:
				case PART_LITERAL:
					if (repeats.subtype & FIXED && repeats.number == 1)
						break;

					/* This will make it a Term, so treat it like one! */
					grammarPart = wrapInTerm(grammarPart);
					/* FALLTHROUGH */
				case PART_TERM:
					/* I'm not merging in terms with a single alternative, because I want to
					   keep the information about conflict resolvers. Then we can bug the user ;-) */
					grammarPart->uTerm.repeats = repeats;
					grammarPart->uTerm.index = listSize(alternative->parts);
					grammarPart->uTerm.enclosing.alternative = alternative;
					break;
				case PART_UNKNOWN:
					break;
				case PART_BACKREF:
					if (repeats.number != 1 || repeats.subtype != FIXED)
						softError(grammarPart->token, "Repetition specification on back-reference operator\n");
					break;
				default:
					PANIC();
			}
			listAppend(alternative->parts, grammarPart);
		}
#line 1312 "grammar.c"
continue;
}
LLscnt[8]--;
break;
}
}
}
static GrammarPart * LL6_element(void){
#line 652 "grammar.g"
GrammarPart *
#line 1323 "grammar.c"
LLretval;
#line 100 "grammar.g"
Token *
#line 1327 "grammar.c"
identifier;
memset(&LLretval, 0, sizeof(LLretval));
memset(&identifier, 0, sizeof(identifier));
{
LL_0:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 5:/* MISSING_ELEMENT */
LLscnt[10]--;
LL_SCANDONE(261);/* MISSING_ELEMENT */
#line 655 "grammar.g"
{
		LLretval = newGrammarPart(NULL, PART_UNKNOWN);
	}
#line 1345 "grammar.c"
LLread();
break;
case 21:/* C_DECL */
LLscnt[10]--;
LL_SCANDONE(277);/* C_DECL */
#line 660 "grammar.g"
{
		LLretval = newGrammarPart(NULL, PART_ACTION);
		LLretval->uAction = newCCode();
	}
#line 1356 "grammar.c"
LLread();
break;
case 37:/* '[' */
LLscnt[10]--;
LLscnt[11]++;
LLscnt[5]++;
LLtcnt[38]++;
LL_SCANDONE(91);/* '[' */
#line 666 "grammar.g"
{
		LLretval = newGrammarPart(newToken(), PART_TERM);
	}
#line 1369 "grammar.c"
LLread();
for (;;) {
LL_1:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_1;
break;
case 1:/* IDENTIFIER */
case 3:/* LITERAL */
case 5:/* MISSING_ELEMENT */
case 12:/* IF */
case 14:/* AVOID */
case 15:/* PREFER */
case 16:/* DEFAULT */
case 21:/* C_DECL */
case 28:/* BACKREF */
case 36:/* '|' */
case 37:/* '[' */
case 38:/* ']' */
break;
case 11:/* PERSISTENT */
case 13:/* WHILE */
switch (LLcsymb) {
case 13:/* WHILE */
LLtcnt[22]++;
LL_SCANDONE(269);/* WHILE */
LLread();
LLtcnt[22]--;
LL_SCANDONE(278);/* C_EXPR */
#line 672 "grammar.g"
{
			if (LLretval->uTerm.flags & TERM_WHILE) {
				error(NULL, "%%while specified more than once in a single term\n");
			} else {
				LLretval->uTerm.flags |= TERM_WHILE;
				LLretval->uTerm.expression = newCCode();
			}
		}
#line 1408 "grammar.c"
LLread();
break;
default:
LL_SCANDONE(267);/* PERSISTENT */
#line 682 "grammar.g"
{
			if (LLretval->uTerm.flags & TERM_PERSISTENT)
				error(NULL, "%%persistent specified more than once in a single term\n");
			LLretval->uTerm.flags |= TERM_PERSISTENT;
		}
#line 1419 "grammar.c"
LLread();
break;
}
continue;
}
LLscnt[11]--;
break;
}
LLscnt[5]--;
LL4_productions
#line 689 "grammar.g"
(&LLretval->uTerm)
#line 1432 "grammar.c"
;
LLtcnt[38]--;
LL_SCANDONE(93);/* ']' */
LLread();
break;
case 3:/* LITERAL */
LLscnt[10]--;
LL_SCANDONE(259);/* LITERAL */
#line 693 "grammar.g"
{
		LLretval = newGrammarPart(newToken(), PART_LITERAL);
		/* GRAM_TERMINAL(LLretval) = literalToTerminal((LLretval)->token->text); */
	}
#line 1446 "grammar.c"
LLread();
break;
case 1:/* IDENTIFIER */
LLscnt[10]--;
LLtcnt[32]++;
LLtcnt[22]++;
LL_SCANDONE(257);/* IDENTIFIER */
#line 699 "grammar.g"
{
		LLretval = newGrammarPart(newToken(), PART_UNDETERMINED);
	}
#line 1458 "grammar.c"
LLread();
LL_2:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_2;
LLtcnt[32]--;
break;
case 1:/* IDENTIFIER */
case 2:/* NUMBER */
case 3:/* LITERAL */
case 5:/* MISSING_ELEMENT */
case 21:/* C_DECL */
case 22:/* C_EXPR */
case 28:/* BACKREF */
case 29:/* DOTQMARK */
case 31:/* ';' */
case 33:/* '*' */
case 36:/* '|' */
case 37:/* '[' */
case 38:/* ']' */
case 39:/* '+' */
case 40:/* '?' */
LLtcnt[32]--;
break;
case 32:/* '<' */
LLtcnt[32]--;
LLscnt[1]++;
LLtcnt[34]++;
LL_SCANDONE(60);/* '<' */
LLread();
identifier = LL1_identifier();
#line 705 "grammar.g"
{
			LLretval->uNonTerminal.retvalIdent = identifier;
			if (identifier != NULL) {
				if (strcmp("LLretval", identifier->text) == 0)
					LLretval->uNonTerminal.flags |= CALL_LLRETVAL;
				else if (strcmp("LLdiscard", identifier->text) == 0)
					LLretval->uNonTerminal.flags |= CALL_LLDISCARD;
			}
		}
#line 1500 "grammar.c"
LLread();
LLtcnt[34]--;
LL_SCANDONE(62);/* '>' */
LLread();
}
LL_3:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_3;
LLtcnt[22]--;
break;
case 1:/* IDENTIFIER */
case 2:/* NUMBER */
case 3:/* LITERAL */
case 5:/* MISSING_ELEMENT */
case 21:/* C_DECL */
case 28:/* BACKREF */
case 29:/* DOTQMARK */
case 31:/* ';' */
case 33:/* '*' */
case 36:/* '|' */
case 37:/* '[' */
case 38:/* ']' */
case 39:/* '+' */
case 40:/* '?' */
LLtcnt[22]--;
break;
case 22:/* C_EXPR */
LLtcnt[22]--;
LL_SCANDONE(278);/* C_EXPR */
#line 718 "grammar.g"
{
			(LLretval)->uNonTerminal.expression = newCCode();
		}
#line 1535 "grammar.c"
LLread();
}
break;
case 28:/* BACKREF */
LLscnt[10]--;
LL_SCANDONE(284);/* BACKREF */
#line 724 "grammar.g"
{
		LLretval = newGrammarPart(newToken(), PART_BACKREF);
		if (option.llgenMode)
			error(LLretval->token, "Back-reference operator is not supported in LLgen mode\n");
	}
#line 1548 "grammar.c"
LLread();
break;
}
}
return LLretval;
}
static Repeats LL7_repeats(void){
#line 731 "grammar.g"
Repeats
#line 1558 "grammar.c"
LLretval;
memset(&LLretval, 0, sizeof(LLretval));
{
LL_0:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_0;
/*FALLTHROUGH*/
case 1:/* IDENTIFIER */
case 3:/* LITERAL */
case 5:/* MISSING_ELEMENT */
case 21:/* C_DECL */
case 28:/* BACKREF */
case 31:/* ';' */
case 36:/* '|' */
case 37:/* '[' */
case 38:/* ']' */
LLscnt[9]--;
#line 733 "grammar.g"
{
		LLretval.subtype = FIXED;
		LLretval.number = 1;
	}
#line 1583 "grammar.c"
break;
case 33:/* '*' */
case 39:/* '+' */
LLscnt[9]--;
LLscnt[12]++;
LLtcnt[2]++;
LL_1:
switch (LLcsymb) {
default:
if (LLskip())
goto LL_1;
/*FALLTHROUGH*/
case 33:/* '*' */
LLscnt[12]--;
LL_SCANDONE(42);/* '*' */
#line 740 "grammar.g"
{
			LLretval.subtype = STAR;
			LLretval.number = -1;
		}
#line 1604 "grammar.c"
break;
case 39:/* '+' */
LLscnt[12]--;
LL_SCANDONE(43);/* '+' */
#line 747 "grammar.g"
{
			LLretval.subtype = PLUS;
			LLretval.number = -1;
		}
#line 1614 "grammar.c"
break;
}
LLread();
LL_2:
switch (LLcsymb) {
default:
if (LLskip()) goto LL_2;
LLtcnt[2]--;
break;
case 1:/* IDENTIFIER */
case 3:/* LITERAL */
case 5:/* MISSING_ELEMENT */
case 21:/* C_DECL */
case 28:/* BACKREF */
case 31:/* ';' */
case 36:/* '|' */
case 37:/* '[' */
case 38:/* ']' */
LLtcnt[2]--;
break;
case 2:/* NUMBER */
LLtcnt[2]--;
LL_SCANDONE(258);/* NUMBER */
#line 754 "grammar.g"
{
			long value;
			errno = 0;
			value = strtol(yytext, NULL, 10);
			if (errno == ERANGE || value > INT_MAX)
				error(NULL, "Number of repetitions too large\n");
			if (value <= 0) {
				PANIC();
				/* The lexer only returns numbers without a sign, therefore the
				   parser should PANIC when it does happen. */
			}
			LLretval.number = value;
			if (LLretval.number == 1) {
				if (LLretval.subtype == PLUS) {
					LLretval.subtype = FIXED;
					warning(WARNING_UNMASKED, NULL, "Fixed single repetition specified as '+1'\n");
				} else if (LLretval.subtype == STAR) {
					warning(WARNING_UNMASKED, NULL, "Optional single repetition specified as '*1' (instead of '?')\n");
				} else {
					PANIC();
					/* If the subtype is not PLUS it should always be STAR. If it is not,
					   something is very wrong. */
				}
			}
		}
#line 1664 "grammar.c"
LLread();
}
break;
case 2:/* NUMBER */
LLscnt[9]--;
LL_SCANDONE(258);/* NUMBER */
#line 782 "grammar.g"
{
		long value;
		LLretval.subtype = FIXED;
		errno = 0;
		value = strtol(yytext, NULL, 10);
		if (errno == ERANGE || value > 32767)
			error(NULL, "Number of repetitions too large\n");
		if (value <= 0) {
			PANIC();
			/* The lexer only returns numbers without a sign, therefore the
			   parser should PANIC when it does happen. */
		}
		LLretval.number = value;
	}
#line 1686 "grammar.c"
LLread();
break;
case 40:/* '?' */
LLscnt[9]--;
LL_SCANDONE(63);/* '?' */
#line 798 "grammar.g"
{
		LLretval.subtype = STAR;
		LLretval.number = 1;
	}
#line 1697 "grammar.c"
LLread();
break;
case 29:/* DOTQMARK */
LLscnt[9]--;
LL_SCANDONE(285);/* DOTQMARK */
#line 804 "grammar.g"
{
		LLretval.subtype = FINOPT;
		LLretval.number = 1;
	}
#line 1708 "grammar.c"
LLread();
break;
}
}
return LLretval;
}
void parser(void) {
	int LLcounts[LL_NTERMINALS + LL_NSETS + 2];
	int *LLbackupLLscnt = LLscnt, *LLbackupLLtcnt = LLtcnt;
	int LLbackupLLreissue = LLreissue;
	LLcounts[0] = LLsymb; LLcounts[1] = LLcsymb;
	LLtcnt = LLcounts + 2; LLscnt = LLcounts + 2 + LL_NTERMINALS;
	memset(LLscnt, 0, LL_NSETS * sizeof(int));
	memset(LLtcnt, 0, LL_NTERMINALS * sizeof(int));
	LLtcnt[0]++;
	LLsymb = 0;
	LLreissue = -2 /* LL_NEW_TOKEN */;
	LLread();
	LL0_specification();
	if (LLcsymb != 0) LLerror(256 /* EOFILE*/);
	LLscnt = LLbackupLLscnt; LLtcnt = LLbackupLLtcnt;
	LLsymb = LLcounts[0]; LLcsymb = LLcounts[1];
	LLreissue = LLbackupLLreissue;
}

